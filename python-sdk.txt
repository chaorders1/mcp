├── .github
    ├── ISSUE_TEMPLATE
    │   ├── bug_report.md
    │   └── feature_request.md
    └── workflows
    │   ├── main-checks.yml
    │   ├── publish-pypi.yml
    │   ├── pull-request-checks.yml
    │   └── shared.yml
├── .gitignore
├── .python-version
├── CODE_OF_CONDUCT.md
├── CONTRIBUTING.md
├── LICENSE
├── README.md
├── RELEASE.md
├── SECURITY.md
├── examples
    ├── README.md
    └── servers
    │   ├── simple-prompt
    │       ├── .python-version
    │       ├── README.md
    │       ├── mcp_simple_prompt
    │       │   ├── __init__.py
    │       │   ├── __main__.py
    │       │   └── server.py
    │       └── pyproject.toml
    │   ├── simple-resource
    │       ├── .python-version
    │       ├── README.md
    │       ├── mcp_simple_resource
    │       │   ├── __init__.py
    │       │   ├── __main__.py
    │       │   └── server.py
    │       └── pyproject.toml
    │   └── simple-tool
    │       ├── .python-version
    │       ├── README.md
    │       ├── mcp_simple_tool
    │           ├── __init__.py
    │           ├── __main__.py
    │           └── server.py
    │       └── pyproject.toml
├── pyproject.toml
├── src
    └── mcp
    │   ├── __init__.py
    │   ├── client
    │       ├── __init__.py
    │       ├── __main__.py
    │       ├── session.py
    │       ├── sse.py
    │       └── stdio.py
    │   ├── py.typed
    │   ├── server
    │       ├── __init__.py
    │       ├── __main__.py
    │       ├── models.py
    │       ├── session.py
    │       ├── sse.py
    │       ├── stdio.py
    │       └── websocket.py
    │   ├── shared
    │       ├── __init__.py
    │       ├── context.py
    │       ├── exceptions.py
    │       ├── memory.py
    │       ├── progress.py
    │       ├── session.py
    │       └── version.py
    │   └── types.py
├── tests
    ├── __init__.py
    ├── client
    │   ├── __init__.py
    │   ├── test_session.py
    │   └── test_stdio.py
    ├── conftest.py
    ├── server
    │   ├── __init__.py
    │   ├── test_session.py
    │   └── test_stdio.py
    ├── shared
    │   └── test_memory.py
    └── test_types.py
└── uv.lock


/.github/ISSUE_TEMPLATE/bug_report.md:
--------------------------------------------------------------------------------
 1 | ---
 2 | name: Bug report
 3 | about: Create a report to help us improve
 4 | title: ''
 5 | labels: ''
 6 | assignees: ''
 7 | 
 8 | ---
 9 | 
10 | **Describe the bug**
11 | A clear and concise description of what the bug is.
12 | 
13 | **To Reproduce**
14 | Steps to reproduce the behavior:
15 | 1. Go to '...'
16 | 2. Click on '....'
17 | 3. Scroll down to '....'
18 | 4. See error
19 | 
20 | **Expected behavior**
21 | A clear and concise description of what you expected to happen.
22 | 
23 | **Screenshots**
24 | If applicable, add screenshots to help explain your problem.
25 | 
26 | **Desktop (please complete the following information):**
27 |  - OS: [e.g. iOS]
28 |  - Browser [e.g. chrome, safari]
29 |  - Version [e.g. 22]
30 | 
31 | **Smartphone (please complete the following information):**
32 |  - Device: [e.g. iPhone6]
33 |  - OS: [e.g. iOS8.1]
34 |  - Browser [e.g. stock browser, safari]
35 |  - Version [e.g. 22]
36 | 
37 | **Additional context**
38 | Add any other context about the problem here.
39 | 


--------------------------------------------------------------------------------
/.github/ISSUE_TEMPLATE/feature_request.md:
--------------------------------------------------------------------------------
 1 | ---
 2 | name: Feature request
 3 | about: Suggest an idea for this project
 4 | title: ''
 5 | labels: ''
 6 | assignees: ''
 7 | 
 8 | ---
 9 | 
10 | **Is your feature request related to a problem? Please describe.**
11 | A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
12 | 
13 | **Describe the solution you'd like**
14 | A clear and concise description of what you want to happen.
15 | 
16 | **Describe alternatives you've considered**
17 | A clear and concise description of any alternative solutions or features you've considered.
18 | 
19 | **Additional context**
20 | Add any other context or screenshots about the feature request here.
21 | 


--------------------------------------------------------------------------------
/.github/workflows/main-checks.yml:
--------------------------------------------------------------------------------
 1 | name: Main branch checks
 2 | 
 3 | on:
 4 |   push:
 5 |     branches: [main]
 6 | 
 7 | jobs:
 8 |   checks:
 9 |     uses: ./.github/workflows/shared.yml
10 | 


--------------------------------------------------------------------------------
/.github/workflows/publish-pypi.yml:
--------------------------------------------------------------------------------
 1 | name: Publishing
 2 | 
 3 | on:
 4 |   release:
 5 |     types: [published]
 6 | 
 7 | jobs:
 8 |   release-build:
 9 |     name: Build distribution
10 |     runs-on: ubuntu-latest
11 |     needs: [checks]
12 |     steps:
13 |     - uses: actions/checkout@v4
14 | 
15 |     - name: Install uv
16 |       uses: astral-sh/setup-uv@v3
17 | 
18 |     - name: "Set up Python"
19 |       uses: actions/setup-python@v5
20 |       with:
21 |         python-version-file: ".python-version"
22 | 
23 |     - name: Install the project
24 |       run: uv sync --frozen --all-extras --dev
25 | 
26 |     - name: Build
27 |       run: uv build
28 | 
29 |     - name: Upload artifacts
30 |       uses: actions/upload-artifact@v4
31 |       with:
32 |         name: release-dists
33 |         path: dist/
34 | 
35 |   checks:
36 |     uses: ./.github/workflows/shared.yml
37 | 
38 |   pypi-publish:
39 |     name: Upload release to PyPI
40 |     runs-on: ubuntu-latest
41 |     environment: release
42 |     needs:
43 |       - release-build
44 |     permissions:
45 |       id-token: write  # IMPORTANT: this permission is mandatory for trusted publishing
46 | 
47 |     steps:
48 |     - name: Retrieve release distributions
49 |       uses: actions/download-artifact@v4
50 |       with:
51 |         name: release-dists
52 |         path: dist/
53 | 
54 |     - name: Publish package distributions to PyPI
55 |       uses: pypa/gh-action-pypi-publish@release/v1
56 | 


--------------------------------------------------------------------------------
/.github/workflows/pull-request-checks.yml:
--------------------------------------------------------------------------------
1 | name: Pull request checks
2 | 
3 | on:
4 |   pull_request:
5 | 
6 | jobs:
7 |   checks:
8 |     uses: ./.github/workflows/shared.yml
9 | 


--------------------------------------------------------------------------------
/.github/workflows/shared.yml:
--------------------------------------------------------------------------------
 1 | name: Shared Checks
 2 | 
 3 | on:
 4 |   workflow_call:
 5 | 
 6 | jobs:
 7 |   format:
 8 |     runs-on: ubuntu-latest
 9 |     steps:
10 |       - uses: actions/checkout@v4
11 | 
12 |       - name: Install uv
13 |         uses: astral-sh/setup-uv@v3
14 |         with:
15 |           enable-cache: true
16 | 
17 |       - name: "Set up Python"
18 |         uses: actions/setup-python@v5
19 |         with:
20 |           python-version-file: ".python-version"
21 | 
22 |       - name: Install the project
23 |         run: uv sync --frozen --all-extras --dev
24 | 
25 |       - name: Run ruff format check
26 |         run: uv run --frozen ruff check .
27 | 
28 |   typecheck:
29 |     runs-on: ubuntu-latest
30 |     steps:
31 |       - uses: actions/checkout@v4
32 | 
33 |       - name: Install uv
34 |         uses: astral-sh/setup-uv@v3
35 |         with:
36 |           enable-cache: true
37 | 
38 |       - name: "Set up Python"
39 |         uses: actions/setup-python@v5
40 |         with:
41 |           python-version-file: ".python-version"
42 | 
43 |       - name: Install the project
44 |         run: uv sync --frozen --all-extras --dev
45 | 
46 |       - name: Run pyright
47 |         run: uv run --frozen pyright
48 | 
49 |   build:
50 |     runs-on: ubuntu-latest
51 | 
52 |     steps:
53 |       - uses: actions/checkout@v4
54 | 
55 |       - name: Install uv
56 |         uses: astral-sh/setup-uv@v3
57 |         with:
58 |           enable-cache: true
59 | 
60 |       - name: "Set up Python"
61 |         uses: actions/setup-python@v5
62 |         with:
63 |           python-version-file: ".python-version"
64 | 
65 |       - name: Install the project
66 |         run: uv sync --frozen --all-extras --dev
67 | 
68 |       - name: Run pytest
69 |         run: uv run --frozen pytest
70 | 


--------------------------------------------------------------------------------
/.gitignore:
--------------------------------------------------------------------------------
  1 | # Byte-compiled / optimized / DLL files
  2 | __pycache__/
  3 | *.py[cod]
  4 | *$py.class
  5 | 
  6 | # C extensions
  7 | *.so
  8 | 
  9 | # Distribution / packaging
 10 | .Python
 11 | build/
 12 | develop-eggs/
 13 | dist/
 14 | downloads/
 15 | eggs/
 16 | .eggs/
 17 | lib/
 18 | lib64/
 19 | parts/
 20 | sdist/
 21 | var/
 22 | wheels/
 23 | share/python-wheels/
 24 | *.egg-info/
 25 | .installed.cfg
 26 | *.egg
 27 | MANIFEST
 28 | 
 29 | # PyInstaller
 30 | #  Usually these files are written by a python script from a template
 31 | #  before PyInstaller builds the exe, so as to inject date/other infos into it.
 32 | *.manifest
 33 | *.spec
 34 | 
 35 | # Installer logs
 36 | pip-log.txt
 37 | pip-delete-this-directory.txt
 38 | 
 39 | # Unit test / coverage reports
 40 | htmlcov/
 41 | .tox/
 42 | .nox/
 43 | .coverage
 44 | .coverage.*
 45 | .cache
 46 | nosetests.xml
 47 | coverage.xml
 48 | *.cover
 49 | *.py,cover
 50 | .hypothesis/
 51 | .pytest_cache/
 52 | cover/
 53 | 
 54 | # Translations
 55 | *.mo
 56 | *.pot
 57 | 
 58 | # Django stuff:
 59 | *.log
 60 | local_settings.py
 61 | db.sqlite3
 62 | db.sqlite3-journal
 63 | 
 64 | # Flask stuff:
 65 | instance/
 66 | .webassets-cache
 67 | 
 68 | # Scrapy stuff:
 69 | .scrapy
 70 | 
 71 | # Sphinx documentation
 72 | docs/_build/
 73 | 
 74 | # PyBuilder
 75 | .pybuilder/
 76 | target/
 77 | 
 78 | # Jupyter Notebook
 79 | .ipynb_checkpoints
 80 | 
 81 | # IPython
 82 | profile_default/
 83 | ipython_config.py
 84 | 
 85 | # pyenv
 86 | #   For a library or package, you might want to ignore these files since the code is
 87 | #   intended to run in multiple environments; otherwise, check them in:
 88 | # .python-version
 89 | 
 90 | # pipenv
 91 | #   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
 92 | #   However, in case of collaboration, if having platform-specific dependencies or dependencies
 93 | #   having no cross-platform support, pipenv may install dependencies that don't work, or not
 94 | #   install all needed dependencies.
 95 | #Pipfile.lock
 96 | 
 97 | # poetry
 98 | #   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
 99 | #   This is especially recommended for binary packages to ensure reproducibility, and is more
100 | #   commonly ignored for libraries.
101 | #   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
102 | #poetry.lock
103 | 
104 | # pdm
105 | #   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
106 | #pdm.lock
107 | #   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
108 | #   in version control.
109 | #   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
110 | .pdm.toml
111 | .pdm-python
112 | .pdm-build/
113 | 
114 | # PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
115 | __pypackages__/
116 | 
117 | # Celery stuff
118 | celerybeat-schedule
119 | celerybeat.pid
120 | 
121 | # SageMath parsed files
122 | *.sage.py
123 | 
124 | # Environments
125 | .env
126 | .venv
127 | env/
128 | venv/
129 | ENV/
130 | env.bak/
131 | venv.bak/
132 | 
133 | # Spyder project settings
134 | .spyderproject
135 | .spyproject
136 | 
137 | # Rope project settings
138 | .ropeproject
139 | 
140 | # mkdocs documentation
141 | /site
142 | 
143 | # mypy
144 | .mypy_cache/
145 | .dmypy.json
146 | dmypy.json
147 | 
148 | # Pyre type checker
149 | .pyre/
150 | 
151 | # pytype static type analyzer
152 | .pytype/
153 | 
154 | # Cython debug symbols
155 | cython_debug/
156 | 
157 | # PyCharm
158 | #  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
159 | #  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
160 | #  and can be added to the global gitignore or merged into this file.  For a more nuclear
161 | #  option (not recommended) you can uncomment the following to ignore the entire idea folder.
162 | #.idea/
163 | 


--------------------------------------------------------------------------------
/.python-version:
--------------------------------------------------------------------------------
1 | 3.10
2 | 


--------------------------------------------------------------------------------
/CODE_OF_CONDUCT.md:
--------------------------------------------------------------------------------
  1 | # Contributor Covenant Code of Conduct
  2 | 
  3 | ## Our Pledge
  4 | 
  5 | We as members, contributors, and leaders pledge to make participation in our
  6 | community a harassment-free experience for everyone, regardless of age, body
  7 | size, visible or invisible disability, ethnicity, sex characteristics, gender
  8 | identity and expression, level of experience, education, socio-economic status,
  9 | nationality, personal appearance, race, religion, or sexual identity
 10 | and orientation.
 11 | 
 12 | We pledge to act and interact in ways that contribute to an open, welcoming,
 13 | diverse, inclusive, and healthy community.
 14 | 
 15 | ## Our Standards
 16 | 
 17 | Examples of behavior that contributes to a positive environment for our
 18 | community include:
 19 | 
 20 | * Demonstrating empathy and kindness toward other people
 21 | * Being respectful of differing opinions, viewpoints, and experiences
 22 | * Giving and gracefully accepting constructive feedback
 23 | * Accepting responsibility and apologizing to those affected by our mistakes,
 24 |   and learning from the experience
 25 | * Focusing on what is best not just for us as individuals, but for the
 26 |   overall community
 27 | 
 28 | Examples of unacceptable behavior include:
 29 | 
 30 | * The use of sexualized language or imagery, and sexual attention or
 31 |   advances of any kind
 32 | * Trolling, insulting or derogatory comments, and personal or political attacks
 33 | * Public or private harassment
 34 | * Publishing others' private information, such as a physical or email
 35 |   address, without their explicit permission
 36 | * Other conduct which could reasonably be considered inappropriate in a
 37 |   professional setting
 38 | 
 39 | ## Enforcement Responsibilities
 40 | 
 41 | Community leaders are responsible for clarifying and enforcing our standards of
 42 | acceptable behavior and will take appropriate and fair corrective action in
 43 | response to any behavior that they deem inappropriate, threatening, offensive,
 44 | or harmful.
 45 | 
 46 | Community leaders have the right and responsibility to remove, edit, or reject
 47 | comments, commits, code, wiki edits, issues, and other contributions that are
 48 | not aligned to this Code of Conduct, and will communicate reasons for moderation
 49 | decisions when appropriate.
 50 | 
 51 | ## Scope
 52 | 
 53 | This Code of Conduct applies within all community spaces, and also applies when
 54 | an individual is officially representing the community in public spaces.
 55 | Examples of representing our community include using an official e-mail address,
 56 | posting via an official social media account, or acting as an appointed
 57 | representative at an online or offline event.
 58 | 
 59 | ## Enforcement
 60 | 
 61 | Instances of abusive, harassing, or otherwise unacceptable behavior may be
 62 | reported to the community leaders responsible for enforcement at
 63 | mcp-coc@anthropic.com.
 64 | All complaints will be reviewed and investigated promptly and fairly.
 65 | 
 66 | All community leaders are obligated to respect the privacy and security of the
 67 | reporter of any incident.
 68 | 
 69 | ## Enforcement Guidelines
 70 | 
 71 | Community leaders will follow these Community Impact Guidelines in determining
 72 | the consequences for any action they deem in violation of this Code of Conduct:
 73 | 
 74 | ### 1. Correction
 75 | 
 76 | **Community Impact**: Use of inappropriate language or other behavior deemed
 77 | unprofessional or unwelcome in the community.
 78 | 
 79 | **Consequence**: A private, written warning from community leaders, providing
 80 | clarity around the nature of the violation and an explanation of why the
 81 | behavior was inappropriate. A public apology may be requested.
 82 | 
 83 | ### 2. Warning
 84 | 
 85 | **Community Impact**: A violation through a single incident or series
 86 | of actions.
 87 | 
 88 | **Consequence**: A warning with consequences for continued behavior. No
 89 | interaction with the people involved, including unsolicited interaction with
 90 | those enforcing the Code of Conduct, for a specified period of time. This
 91 | includes avoiding interactions in community spaces as well as external channels
 92 | like social media. Violating these terms may lead to a temporary or
 93 | permanent ban.
 94 | 
 95 | ### 3. Temporary Ban
 96 | 
 97 | **Community Impact**: A serious violation of community standards, including
 98 | sustained inappropriate behavior.
 99 | 
100 | **Consequence**: A temporary ban from any sort of interaction or public
101 | communication with the community for a specified period of time. No public or
102 | private interaction with the people involved, including unsolicited interaction
103 | with those enforcing the Code of Conduct, is allowed during this period.
104 | Violating these terms may lead to a permanent ban.
105 | 
106 | ### 4. Permanent Ban
107 | 
108 | **Community Impact**: Demonstrating a pattern of violation of community
109 | standards, including sustained inappropriate behavior,  harassment of an
110 | individual, or aggression toward or disparagement of classes of individuals.
111 | 
112 | **Consequence**: A permanent ban from any sort of public interaction within
113 | the community.
114 | 
115 | ## Attribution
116 | 
117 | This Code of Conduct is adapted from the [Contributor Covenant][homepage],
118 | version 2.0, available at
119 | https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.
120 | 
121 | Community Impact Guidelines were inspired by [Mozilla's code of conduct
122 | enforcement ladder](https://github.com/mozilla/diversity).
123 | 
124 | [homepage]: https://www.contributor-covenant.org
125 | 
126 | For answers to common questions about this code of conduct, see the FAQ at
127 | https://www.contributor-covenant.org/faq. Translations are available at
128 | https://www.contributor-covenant.org/translations.
129 | 


--------------------------------------------------------------------------------
/CONTRIBUTING.md:
--------------------------------------------------------------------------------
 1 | # Contributing
 2 | 
 3 | Thank you for your interest in contributing to the MCP Python SDK! This document provides guidelines and instructions for contributing.
 4 | 
 5 | ## Development Setup
 6 | 
 7 | 1. Make sure you have Python 3.10+ installed
 8 | 2. Install [uv](https://docs.astral.sh/uv/getting-started/installation/)
 9 | 3. Fork the repository
10 | 4. Clone your fork: `git clone https://github.com/YOUR-USERNAME/python-sdk.git`
11 | 5. Install dependencies:
12 | ```bash
13 | uv sync --frozen --all-extras --dev
14 | ```
15 | 
16 | ## Development Workflow
17 | 
18 | 1. Create a new branch for your changes
19 | 2. Make your changes
20 | 3. Ensure tests pass:
21 | ```bash 
22 | uv run pytest
23 | ```
24 | 4. Run type checking:
25 | ```bash
26 | uv run pyright
27 | ```
28 | 5. Run linting:
29 | ```bash
30 | uv run ruff check .
31 | uv run ruff format .
32 | ```
33 | 6. Submit a pull request
34 | 
35 | ## Code Style
36 | 
37 | - We use `ruff` for linting and formatting
38 | - Follow PEP 8 style guidelines
39 | - Add type hints to all functions
40 | - Include docstrings for public APIs
41 | 
42 | ## Pull Request Process
43 | 
44 | 1. Update documentation as needed
45 | 2. Add tests for new functionality
46 | 3. Ensure CI passes
47 | 4. Maintainers will review your code
48 | 5. Address review feedback
49 | 
50 | ## Code of Conduct
51 | 
52 | Please note that this project is released with a [Code of Conduct](CODE_OF_CONDUCT.md). By participating in this project you agree to abide by its terms.
53 | 
54 | ## License
55 | 
56 | By contributing, you agree that your contributions will be licensed under the MIT License.
57 | 


--------------------------------------------------------------------------------
/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2024 Anthropic, PBC
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/README.md:
--------------------------------------------------------------------------------
  1 | # MCP Python SDK
  2 | [![PyPI][pypi-badge]][pypi-url]
  3 | [![MIT licensed][mit-badge]][mit-url]
  4 | [![Python Version][python-badge]][python-url]
  5 | [![Documentation][docs-badge]][docs-url]
  6 | [![Specification][spec-badge]][spec-url]
  7 | [![GitHub Discussions][discussions-badge]][discussions-url]
  8 | 
  9 | [pypi-badge]: https://img.shields.io/pypi/v/mcp.svg
 10 | [pypi-url]: https://pypi.org/project/mcp/
 11 | [mit-badge]: https://img.shields.io/pypi/l/mcp.svg
 12 | [mit-url]: https://github.com/modelcontextprotocol/python-sdk/blob/main/LICENSE
 13 | [python-badge]: https://img.shields.io/pypi/pyversions/mcp.svg
 14 | [python-url]: https://www.python.org/downloads/
 15 | [docs-badge]: https://img.shields.io/badge/docs-modelcontextprotocol.io-blue.svg
 16 | [docs-url]: https://modelcontextprotocol.io
 17 | [spec-badge]: https://img.shields.io/badge/spec-spec.modelcontextprotocol.io-blue.svg
 18 | [spec-url]: https://spec.modelcontextprotocol.io
 19 | [discussions-badge]: https://img.shields.io/github/discussions/modelcontextprotocol/python-sdk
 20 | [discussions-url]: https://github.com/modelcontextprotocol/python-sdk/discussions
 21 | 
 22 | Python implementation of the [Model Context Protocol](https://modelcontextprotocol.io) (MCP), providing both client and server capabilities for integrating with LLM surfaces.
 23 | 
 24 | ## Overview
 25 | 
 26 | The Model Context Protocol allows applications to provide context for LLMs in a standardized way, separating the concerns of providing context from the actual LLM interaction. This Python SDK implements the full MCP specification, making it easy to:
 27 | 
 28 | - Build MCP clients that can connect to any MCP server
 29 | - Create MCP servers that expose resources, prompts and tools
 30 | - Use standard transports like stdio and SSE
 31 | - Handle all MCP protocol messages and lifecycle events
 32 | 
 33 | ## Installation
 34 | 
 35 | We recommend the use of [uv](https://docs.astral.sh/uv/) to manage your Python projects:
 36 | 
 37 | ```bash
 38 | uv add mcp
 39 | ```
 40 | 
 41 | Alternatively, add mcp to your `requirements.txt`:
 42 | ```
 43 | pip install mcp
 44 | # or add to requirements.txt
 45 | pip install -r requirements.txt
 46 | ```
 47 | 
 48 | ## Overview
 49 | MCP servers provide focused functionality like resources, tools, prompts, and other capabilities that can be reused across many client applications. These servers are designed to be easy to build, highly composable, and modular.
 50 | 
 51 | ### Key design principles
 52 | - Servers are extremely easy to build with clear, simple interfaces
 53 | - Multiple servers can be composed seamlessly through a shared protocol
 54 | - Each server operates in isolation and cannot access conversation context
 55 | - Features can be added progressively through capability negotiation
 56 | 
 57 | ### Server provided primitives
 58 | - [Prompts](https://modelcontextprotocol.io/docs/concepts/prompts): Templatable text
 59 | - [Resources](https://modelcontextprotocol.io/docs/concepts/resources): File-like attachments
 60 | - [Tools](https://modelcontextprotocol.io/docs/concepts/tools): Functions that models can call
 61 | - Utilities:
 62 |   - Completion: Auto-completion provider for prompt arguments or resource URI templates
 63 |   - Logging: Logging to the client
 64 |   - Pagination*: Pagination for long results
 65 | 
 66 | ### Client provided primitives
 67 |  - [Sampling](https://modelcontextprotocol.io/docs/concepts/sampling): Allow servers to sample using client models
 68 |  - Roots: Information about locations to operate on (e.g., directories)
 69 | 
 70 | Connections between clients and servers are established through transports like **stdio** or **SSE** (Note that most clients support stdio, but not SSE at the moment). The transport layer handles message framing, delivery, and error handling.
 71 | 
 72 | ## Quick Start
 73 | 
 74 | ### Creating a Server
 75 | 
 76 | MCP servers follow a decorator approach to register handlers for MCP primitives like resources, prompts, and tools. The goal is to provide a simple interface for exposing capabilities to LLM clients.
 77 | 
 78 | **example_server.py**
 79 | 
 80 | ```python
 81 | # /// script
 82 | # dependencies = [
 83 | #   "mcp"
 84 | # ]
 85 | # ///
 86 | from mcp.server import Server, NotificationOptions
 87 | from mcp.server.models import InitializationOptions
 88 | import mcp.server.stdio
 89 | import mcp.types as types
 90 | 
 91 | # Create a server instance
 92 | server = Server("example-server")
 93 | 
 94 | # Add prompt capabilities
 95 | @server.list_prompts()
 96 | async def handle_list_prompts() -> list[types.Prompt]:
 97 |     return [
 98 |         types.Prompt(
 99 |             name="example-prompt",
100 |             description="An example prompt template",
101 |             arguments=[
102 |                 types.PromptArgument(
103 |                     name="arg1",
104 |                     description="Example argument",
105 |                     required=True
106 |                 )
107 |             ]
108 |         )
109 |     ]
110 | 
111 | @server.get_prompt()
112 | async def handle_get_prompt(
113 |     name: str,
114 |     arguments: dict[str, str] | None
115 | ) -> types.GetPromptResult:
116 |     if name != "example-prompt":
117 |         raise ValueError(f"Unknown prompt: {name}")
118 | 
119 |     return types.GetPromptResult(
120 |         description="Example prompt",
121 |         messages=[
122 |             types.PromptMessage(
123 |                 role="user",
124 |                 content=types.TextContent(
125 |                     type="text",
126 |                     text="Example prompt text"
127 |                 )
128 |             )
129 |         ]
130 |     )
131 | 
132 | async def run():
133 |     # Run the server as STDIO
134 |     async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
135 |         await server.run(
136 |             read_stream,
137 |             write_stream,
138 |             InitializationOptions(
139 |                 server_name="example",
140 |                 server_version="0.1.0",
141 |                 capabilities=server.get_capabilities(
142 |                     notification_options=NotificationOptions(),
143 |                     experimental_capabilities={},
144 |                 )
145 |             )
146 |         )
147 | 
148 | if __name__ == "__main__":
149 |     import asyncio
150 |     asyncio.run(run())
151 | ```
152 | 
153 | ### Creating a Client
154 | 
155 | **example_client.py**
156 | 
157 | ```python
158 | from mcp import ClientSession, StdioServerParameters
159 | from mcp.client.stdio import stdio_client
160 | 
161 | # Create server parameters for stdio connection
162 | server_params = StdioServerParameters(
163 |     command="python", # Executable
164 |     args=["example_server.py"], # Optional command line arguments
165 |     env=None # Optional environment variables
166 | )
167 | 
168 | async def run():
169 |     async with stdio_client(server_params) as (read, write):
170 |         async with ClientSession(read, write) as session:
171 |             # Initialize the connection
172 |             await session.initialize()
173 | 
174 |             # The example server only supports prompt primitives:
175 |         
176 |             # List available prompts
177 |             prompts = await session.list_prompts()
178 | 
179 |             # Get a prompt
180 |             prompt = await session.get_prompt("example-prompt", arguments={"arg1": "value"})
181 | 
182 |             """
183 |             Other example calls include:
184 | 
185 |             # List available resources
186 |             resources = await session.list_resources()
187 | 
188 |             # List available tools
189 |             tools = await session.list_tools()
190 | 
191 |             # Read a resource
192 |             resource = await session.read_resource("file://some/path")
193 | 
194 |             # Call a tool
195 |             result = await session.call_tool("tool-name", arguments={"arg1": "value"})
196 |             """
197 | 
198 | if __name__ == "__main__":
199 |     import asyncio
200 |     asyncio.run(run())
201 | ```
202 | 
203 | ## Primitives
204 | 
205 | The MCP Python SDK provides decorators that map to the core protocol primitives. Each primitive follows a different interaction pattern based on how it is controlled and used:
206 | 
207 | | Primitive | Control               | Description                                         | Example Use                  |
208 | |-----------|-----------------------|-----------------------------------------------------|------------------------------|
209 | | Prompts   | User-controlled       | Interactive templates invoked by user choice        | Slash commands, menu options |
210 | | Resources | Application-controlled| Contextual data managed by the client application   | File contents, API responses |
211 | | Tools     | Model-controlled      | Functions exposed to the LLM to take actions        | API calls, data updates      |
212 | 
213 | ### User-Controlled Primitives
214 | 
215 | **Prompts** are designed to be explicitly selected by users for their interactions with LLMs.
216 | 
217 | | Decorator                | Description                            |
218 | |--------------------------|----------------------------------------|
219 | | `@server.list_prompts()` | List available prompt templates        |
220 | | `@server.get_prompt()`   | Get a specific prompt with arguments   |
221 | 
222 | ### Application-Controlled Primitives
223 | 
224 | **Resources** are controlled by the client application, which decides how and when they should be used based on its own logic.
225 | 
226 | | Decorator                      | Description                           |
227 | |--------------------------------|---------------------------------------|
228 | | `@server.list_resources()`     | List available resources              |
229 | | `@server.read_resource()`      | Read a specific resource's content    |
230 | | `@server.subscribe_resource()` | Subscribe to resource updates         |
231 | 
232 | ### Model-Controlled Primitives
233 | 
234 | **Tools** are exposed to LLMs to enable automated actions, with user approval.
235 | 
236 | | Decorator              | Description                        |
237 | |------------------------|------------------------------------|
238 | | `@server.list_tools()` | List available tools               |
239 | | `@server.call_tool()`  | Execute a tool with arguments      |
240 | 
241 | ### Server Management
242 | 
243 | Additional decorators for server functionality:
244 | 
245 | | Decorator                     | Description                    |
246 | |-------------------------------|--------------------------------|
247 | | `@server.set_logging_level()` | Update server logging level    |
248 | 
249 | ### Capabilities
250 | 
251 | MCP servers declare capabilities during initialization. These map to specific decorators:
252 | 
253 | | Capability  | Feature Flag                 | Decorators                                                      | Description                        |
254 | |-------------|------------------------------|-----------------------------------------------------------------|-------------------------------------|
255 | | `prompts`   | `listChanged`                | `@list_prompts`<br/>`@get_prompt`                               | Prompt template management          |
256 | | `resources` | `subscribe`<br/>`listChanged`| `@list_resources`<br/>`@read_resource`<br/>`@subscribe_resource`| Resource exposure and updates       |
257 | | `tools`     | `listChanged`                | `@list_tools`<br/>`@call_tool`                                  | Tool discovery and execution        |
258 | | `logging`   | -                            | `@set_logging_level`                                            | Server logging configuration        |
259 | | `completion`| -                            | `@complete_argument`                                            | Argument completion suggestions     |
260 | 
261 | Capabilities are negotiated during connection initialization. Servers only need to implement the decorators for capabilities they support.
262 | 
263 | ## Client Interaction
264 | 
265 | The MCP Python SDK enables servers to interact with clients through request context and session management. This allows servers to perform operations like LLM sampling and progress tracking.
266 | 
267 | ### Request Context
268 | 
269 | The Request Context provides access to the current request and client session. It can be accessed through `server.request_context` and enables:
270 | 
271 | - Sampling from the client's LLM
272 | - Sending progress updates
273 | - Logging messages
274 | - Accessing request metadata
275 | 
276 | Example using request context for LLM sampling:
277 | 
278 | ```python
279 | @server.call_tool()
280 | async def handle_call_tool(name: str, arguments: dict) -> list[types.TextContent]:
281 |     # Access the current request context
282 |     context = server.request_context
283 | 
284 |     # Use the session to sample from the client's LLM
285 |     result = await context.session.create_message(
286 |         messages=[
287 |             types.SamplingMessage(
288 |                 role="user",
289 |                 content=types.TextContent(
290 |                     type="text",
291 |                     text="Analyze this data: " + json.dumps(arguments)
292 |                 )
293 |             )
294 |         ],
295 |         max_tokens=100
296 |     )
297 | 
298 |     return [types.TextContent(type="text", text=result.content.text)]
299 | ```
300 | 
301 | Using request context for progress updates:
302 | 
303 | ```python
304 | @server.call_tool()
305 | async def handle_call_tool(name: str, arguments: dict) -> list[types.TextContent]:
306 |     context = server.request_context
307 | 
308 |     if progress_token := context.meta.progressToken:
309 |         # Send progress notifications
310 |         await context.session.send_progress_notification(
311 |             progress_token=progress_token,
312 |             progress=0.5,
313 |             total=1.0
314 |         )
315 | 
316 |     # Perform operation...
317 | 
318 |     if progress_token:
319 |         await context.session.send_progress_notification(
320 |             progress_token=progress_token,
321 |             progress=1.0,
322 |             total=1.0
323 |         )
324 | 
325 |     return [types.TextContent(type="text", text="Operation complete")]
326 | ```
327 | 
328 | The request context is automatically set for each request and provides a safe way to access the current client session and request metadata.
329 | 
330 | ## Documentation
331 | 
332 | - [Model Context Protocol documentation](https://modelcontextprotocol.io)
333 | - [Model Context Protocol specification](https://spec.modelcontextprotocol.io)
334 | - [Officially supported servers](https://github.com/modelcontextprotocol/servers)
335 | 
336 | ## Contributing
337 | 
338 | We are passionate about supporting contributors of all levels of experience and would love to see you get involved in the project. See the [contributing guide](CONTRIBUTING.md) to get started.
339 | 
340 | ## License
341 | 
342 | This project is licensed under the MIT License - see the LICENSE file for details.
343 | 


--------------------------------------------------------------------------------
/RELEASE.md:
--------------------------------------------------------------------------------
 1 | # Release Process
 2 | 
 3 | ## Bumping Dependencies
 4 | 
 5 | 1. Change dependency
 6 | 2. Upgrade lock with `uv lock --resolution lowest-direct
 7 | 
 8 | ## Major or Minor Release
 9 | 
10 | 1. Create a release branch named `vX.Y.Z` where `X.Y.Z` is the version.
11 | 2. Bump version number on release branch.
12 | 3. Create an annotated, signed tag: `git tag -s -a vX.Y.Z`
13 | 4. Create a github release using `gh release create` and publish it.
14 | 5. Have the release flow being reviewed.
15 | 7. Bump version number on `main` to the next version followed by `.dev`, e.g. `v0.4.0.dev`.
16 | 


--------------------------------------------------------------------------------
/SECURITY.md:
--------------------------------------------------------------------------------
 1 | # Security Policy
 2 | Thank you for helping us keep the SDKs and systems they interact with secure.
 3 | 
 4 | ## Reporting Security Issues
 5 | 
 6 | This SDK is maintained by [Anthropic](https://www.anthropic.com/) as part of the Model Context Protocol project.
 7 | 
 8 | The security of our systems and user data is Anthropic’s top priority. We appreciate the work of security researchers acting in good faith in identifying and reporting potential vulnerabilities.
 9 | 
10 | Our security program is managed on HackerOne and we ask that any validated vulnerability in this functionality be reported through their [submission form](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).
11 | 
12 | ## Vulnerability Disclosure Program
13 | 
14 | Our Vulnerability Program Guidelines are defined on our [HackerOne program page](https://hackerone.com/anthropic-vdp).
15 | 


--------------------------------------------------------------------------------
/examples/README.md:
--------------------------------------------------------------------------------
1 | # Python SDK Examples
2 | 
3 | This folders aims to provide simple examples of using the Python SDK. Please refer to the
4 | [servers repository](https://github.com/modelcontextprotocol/servers)
5 | for real-world servers.
6 | 


--------------------------------------------------------------------------------
/examples/servers/simple-prompt/.python-version:
--------------------------------------------------------------------------------
1 | 3.10
2 | 


--------------------------------------------------------------------------------
/examples/servers/simple-prompt/README.md:
--------------------------------------------------------------------------------
 1 | # MCP Simple Prompt
 2 | 
 3 | A simple MCP server that exposes a customizable prompt template with optional context and topic parameters.
 4 | 
 5 | ## Usage
 6 | 
 7 | Start the server using either stdio (default) or SSE transport:
 8 | 
 9 | ```bash
10 | # Using stdio transport (default)
11 | uv run mcp-simple-prompt
12 | 
13 | # Using SSE transport on custom port
14 | uv run mcp-simple-prompt --transport sse --port 8000
15 | ```
16 | 
17 | The server exposes a prompt named "simple" that accepts two optional arguments:
18 | 
19 | - `context`: Additional context to consider
20 | - `topic`: Specific topic to focus on
21 | 
22 | ## Example
23 | 
24 | Using the MCP client, you can retrieve the prompt like this using the STDIO transport:
25 | 
26 | ```python
27 | import asyncio
28 | from mcp.client.session import ClientSession
29 | from mcp.client.stdio import StdioServerParameters, stdio_client
30 | 
31 | 
32 | async def main():
33 |     async with stdio_client(
34 |         StdioServerParameters(command="uv", args=["run", "mcp-simple-prompt"])
35 |     ) as (read, write):
36 |         async with ClientSession(read, write) as session:
37 |             await session.initialize()
38 | 
39 |             # List available prompts
40 |             prompts = await session.list_prompts()
41 |             print(prompts)
42 | 
43 |             # Get the prompt with arguments
44 |             prompt = await session.get_prompt(
45 |                 "simple",
46 |                 {
47 |                     "context": "User is a software developer",
48 |                     "topic": "Python async programming",
49 |                 },
50 |             )
51 |             print(prompt)
52 | 
53 | 
54 | asyncio.run(main())
55 | ```
56 | 


--------------------------------------------------------------------------------
/examples/servers/simple-prompt/mcp_simple_prompt/__init__.py:
--------------------------------------------------------------------------------
1 | 
2 | 


--------------------------------------------------------------------------------
/examples/servers/simple-prompt/mcp_simple_prompt/__main__.py:
--------------------------------------------------------------------------------
1 | import sys
2 | 
3 | from .server import main
4 | 
5 | sys.exit(main())
6 | 


--------------------------------------------------------------------------------
/examples/servers/simple-prompt/mcp_simple_prompt/server.py:
--------------------------------------------------------------------------------
  1 | import anyio
  2 | import click
  3 | import mcp.types as types
  4 | from mcp.server import Server
  5 | 
  6 | 
  7 | def create_messages(
  8 |     context: str | None = None, topic: str | None = None
  9 | ) -> list[types.PromptMessage]:
 10 |     """Create the messages for the prompt."""
 11 |     messages = []
 12 | 
 13 |     # Add context if provided
 14 |     if context:
 15 |         messages.append(
 16 |             types.PromptMessage(
 17 |                 role="user",
 18 |                 content=types.TextContent(
 19 |                     type="text", text=f"Here is some relevant context: {context}"
 20 |                 ),
 21 |             )
 22 |         )
 23 | 
 24 |     # Add the main prompt
 25 |     prompt = "Please help me with "
 26 |     if topic:
 27 |         prompt += f"the following topic: {topic}"
 28 |     else:
 29 |         prompt += "whatever questions I may have."
 30 | 
 31 |     messages.append(
 32 |         types.PromptMessage(
 33 |             role="user", content=types.TextContent(type="text", text=prompt)
 34 |         )
 35 |     )
 36 | 
 37 |     return messages
 38 | 
 39 | 
 40 | @click.command()
 41 | @click.option("--port", default=8000, help="Port to listen on for SSE")
 42 | @click.option(
 43 |     "--transport",
 44 |     type=click.Choice(["stdio", "sse"]),
 45 |     default="stdio",
 46 |     help="Transport type",
 47 | )
 48 | def main(port: int, transport: str) -> int:
 49 |     app = Server("mcp-simple-prompt")
 50 | 
 51 |     @app.list_prompts()
 52 |     async def list_prompts() -> list[types.Prompt]:
 53 |         return [
 54 |             types.Prompt(
 55 |                 name="simple",
 56 |                 description="A simple prompt that can take optional context and topic "
 57 |                 "arguments",
 58 |                 arguments=[
 59 |                     types.PromptArgument(
 60 |                         name="context",
 61 |                         description="Additional context to consider",
 62 |                         required=False,
 63 |                     ),
 64 |                     types.PromptArgument(
 65 |                         name="topic",
 66 |                         description="Specific topic to focus on",
 67 |                         required=False,
 68 |                     ),
 69 |                 ],
 70 |             )
 71 |         ]
 72 | 
 73 |     @app.get_prompt()
 74 |     async def get_prompt(
 75 |         name: str, arguments: dict[str, str] | None = None
 76 |     ) -> types.GetPromptResult:
 77 |         if name != "simple":
 78 |             raise ValueError(f"Unknown prompt: {name}")
 79 | 
 80 |         if arguments is None:
 81 |             arguments = {}
 82 | 
 83 |         return types.GetPromptResult(
 84 |             messages=create_messages(
 85 |                 context=arguments.get("context"), topic=arguments.get("topic")
 86 |             ),
 87 |             description="A simple prompt with optional context and topic arguments",
 88 |         )
 89 | 
 90 |     if transport == "sse":
 91 |         from mcp.server.sse import SseServerTransport
 92 |         from starlette.applications import Starlette
 93 |         from starlette.routing import Route
 94 | 
 95 |         sse = SseServerTransport("/messages")
 96 | 
 97 |         async def handle_sse(request):
 98 |             async with sse.connect_sse(
 99 |                 request.scope, request.receive, request._send
100 |             ) as streams:
101 |                 await app.run(
102 |                     streams[0], streams[1], app.create_initialization_options()
103 |                 )
104 | 
105 |         async def handle_messages(request):
106 |             await sse.handle_post_message(request.scope, request.receive, request._send)
107 | 
108 |         starlette_app = Starlette(
109 |             debug=True,
110 |             routes=[
111 |                 Route("/sse", endpoint=handle_sse),
112 |                 Route("/messages", endpoint=handle_messages, methods=["POST"]),
113 |             ],
114 |         )
115 | 
116 |         import uvicorn
117 | 
118 |         uvicorn.run(starlette_app, host="0.0.0.0", port=port)
119 |     else:
120 |         from mcp.server.stdio import stdio_server
121 | 
122 |         async def arun():
123 |             async with stdio_server() as streams:
124 |                 await app.run(
125 |                     streams[0], streams[1], app.create_initialization_options()
126 |                 )
127 | 
128 |         anyio.run(arun)
129 | 
130 |     return 0
131 | 


--------------------------------------------------------------------------------
/examples/servers/simple-prompt/pyproject.toml:
--------------------------------------------------------------------------------
 1 | [project]
 2 | name = "mcp-simple-prompt"
 3 | version = "0.1.0"
 4 | description = "A simple MCP server exposing a customizable prompt"
 5 | readme = "README.md"
 6 | requires-python = ">=3.10"
 7 | authors = [{ name = "Anthropic, PBC." }]
 8 | maintainers = [
 9 |     { name = "David Soria Parra", email = "davidsp@anthropic.com" },
10 |     { name = "Justin Spahr-Summers", email = "justin@anthropic.com" },
11 | ]
12 | keywords = ["mcp", "llm", "automation", "web", "fetch"]
13 | license = { text = "MIT" }
14 | classifiers = [
15 |     "Development Status :: 4 - Beta",
16 |     "Intended Audience :: Developers",
17 |     "License :: OSI Approved :: MIT License",
18 |     "Programming Language :: Python :: 3",
19 |     "Programming Language :: Python :: 3.10",
20 | ]
21 | dependencies = ["anyio>=4.5", "click>=8.1.0", "httpx>=0.27", "mcp"]
22 | 
23 | [project.scripts]
24 | mcp-simple-prompt = "mcp_simple_prompt.server:main"
25 | 
26 | [build-system]
27 | requires = ["hatchling"]
28 | build-backend = "hatchling.build"
29 | 
30 | [tool.hatch.build.targets.wheel]
31 | packages = ["mcp_simple_prompt"]
32 | 
33 | [tool.pyright]
34 | include = ["mcp_simple_prompt"]
35 | venvPath = "."
36 | venv = ".venv"
37 | 
38 | [tool.ruff.lint]
39 | select = ["E", "F", "I"]
40 | ignore = []
41 | 
42 | [tool.ruff]
43 | line-length = 88
44 | target-version = "py310"
45 | 
46 | [tool.uv]
47 | dev-dependencies = ["pyright>=1.1.378", "pytest>=8.3.3", "ruff>=0.6.9"]
48 | 


--------------------------------------------------------------------------------
/examples/servers/simple-resource/.python-version:
--------------------------------------------------------------------------------
1 | 3.10
2 | 


--------------------------------------------------------------------------------
/examples/servers/simple-resource/README.md:
--------------------------------------------------------------------------------
 1 | # MCP Simple Resource
 2 | 
 3 | A simple MCP server that exposes sample text files as resources.
 4 | 
 5 | ## Usage
 6 | 
 7 | Start the server using either stdio (default) or SSE transport:
 8 | 
 9 | ```bash
10 | # Using stdio transport (default)
11 | uv run mcp-simple-resource
12 | 
13 | # Using SSE transport on custom port
14 | uv run mcp-simple-resource --transport sse --port 8000
15 | ```
16 | 
17 | The server exposes some basic text file resources that can be read by clients.
18 | 
19 | ## Example
20 | 
21 | Using the MCP client, you can retrieve resources like this using the STDIO transport:
22 | 
23 | ```python
24 | import asyncio
25 | from mcp.types import AnyUrl
26 | from mcp.client.session import ClientSession
27 | from mcp.client.stdio import StdioServerParameters, stdio_client
28 | 
29 | 
30 | async def main():
31 |     async with stdio_client(
32 |         StdioServerParameters(command="uv", args=["run", "mcp-simple-resource"])
33 |     ) as (read, write):
34 |         async with ClientSession(read, write) as session:
35 |             await session.initialize()
36 | 
37 |             # List available resources
38 |             resources = await session.list_resources()
39 |             print(resources)
40 | 
41 |             # Get a specific resource
42 |             resource = await session.read_resource(AnyUrl("file:///greeting.txt"))
43 |             print(resource)
44 | 
45 | 
46 | asyncio.run(main())
47 | 
48 | ```
49 | 


--------------------------------------------------------------------------------
/examples/servers/simple-resource/mcp_simple_resource/__init__.py:
--------------------------------------------------------------------------------
1 | 
2 | 


--------------------------------------------------------------------------------
/examples/servers/simple-resource/mcp_simple_resource/__main__.py:
--------------------------------------------------------------------------------
1 | import sys
2 | 
3 | from server import main
4 | 
5 | sys.exit(main())
6 | 


--------------------------------------------------------------------------------
/examples/servers/simple-resource/mcp_simple_resource/server.py:
--------------------------------------------------------------------------------
 1 | import anyio
 2 | import click
 3 | import mcp.types as types
 4 | from mcp.server import AnyUrl, Server
 5 | 
 6 | SAMPLE_RESOURCES = {
 7 |     "greeting": "Hello! This is a sample text resource.",
 8 |     "help": "This server provides a few sample text resources for testing.",
 9 |     "about": "This is the simple-resource MCP server implementation.",
10 | }
11 | 
12 | 
13 | @click.command()
14 | @click.option("--port", default=8000, help="Port to listen on for SSE")
15 | @click.option(
16 |     "--transport",
17 |     type=click.Choice(["stdio", "sse"]),
18 |     default="stdio",
19 |     help="Transport type",
20 | )
21 | def main(port: int, transport: str) -> int:
22 |     app = Server("mcp-simple-resource")
23 | 
24 |     @app.list_resources()
25 |     async def list_resources() -> list[types.Resource]:
26 |         return [
27 |             types.Resource(
28 |                 uri=AnyUrl(f"file:///{name}.txt"),
29 |                 name=name,
30 |                 description=f"A sample text resource named {name}",
31 |                 mimeType="text/plain",
32 |             )
33 |             for name in SAMPLE_RESOURCES.keys()
34 |         ]
35 | 
36 |     @app.read_resource()
37 |     async def read_resource(uri: AnyUrl) -> str | bytes:
38 |         assert uri.path is not None
39 |         name = uri.path.replace(".txt", "").lstrip("/")
40 | 
41 |         if name not in SAMPLE_RESOURCES:
42 |             raise ValueError(f"Unknown resource: {uri}")
43 | 
44 |         return SAMPLE_RESOURCES[name]
45 | 
46 |     if transport == "sse":
47 |         from mcp.server.sse import SseServerTransport
48 |         from starlette.applications import Starlette
49 |         from starlette.routing import Route
50 | 
51 |         sse = SseServerTransport("/messages")
52 | 
53 |         async def handle_sse(request):
54 |             async with sse.connect_sse(
55 |                 request.scope, request.receive, request._send
56 |             ) as streams:
57 |                 await app.run(
58 |                     streams[0], streams[1], app.create_initialization_options()
59 |                 )
60 | 
61 |         async def handle_messages(request):
62 |             await sse.handle_post_message(request.scope, request.receive, request._send)
63 | 
64 |         starlette_app = Starlette(
65 |             debug=True,
66 |             routes=[
67 |                 Route("/sse", endpoint=handle_sse),
68 |                 Route("/messages", endpoint=handle_messages, methods=["POST"]),
69 |             ],
70 |         )
71 | 
72 |         import uvicorn
73 | 
74 |         uvicorn.run(starlette_app, host="0.0.0.0", port=port)
75 |     else:
76 |         from mcp.server.stdio import stdio_server
77 | 
78 |         async def arun():
79 |             async with stdio_server() as streams:
80 |                 await app.run(
81 |                     streams[0], streams[1], app.create_initialization_options()
82 |                 )
83 | 
84 |         anyio.run(arun)
85 | 
86 |     return 0
87 | 


--------------------------------------------------------------------------------
/examples/servers/simple-resource/pyproject.toml:
--------------------------------------------------------------------------------
 1 | [project]
 2 | name = "mcp-simple-resource"
 3 | version = "0.1.0"
 4 | description = "A simple MCP server exposing sample text resources"
 5 | readme = "README.md"
 6 | requires-python = ">=3.10"
 7 | authors = [{ name = "Anthropic, PBC." }]
 8 | maintainers = [
 9 |     { name = "David Soria Parra", email = "davidsp@anthropic.com" },
10 |     { name = "Justin Spahr-Summers", email = "justin@anthropic.com" },
11 | ]
12 | keywords = ["mcp", "llm", "automation", "web", "fetch"]
13 | license = { text = "MIT" }
14 | classifiers = [
15 |     "Development Status :: 4 - Beta",
16 |     "Intended Audience :: Developers",
17 |     "License :: OSI Approved :: MIT License",
18 |     "Programming Language :: Python :: 3",
19 |     "Programming Language :: Python :: 3.10",
20 | ]
21 | dependencies = ["anyio>=4.5", "click>=8.1.0", "httpx>=0.27", "mcp"]
22 | 
23 | [project.scripts]
24 | mcp-simple-resource = "mcp_simple_resource.server:main"
25 | 
26 | [build-system]
27 | requires = ["hatchling"]
28 | build-backend = "hatchling.build"
29 | 
30 | [tool.hatch.build.targets.wheel]
31 | packages = ["mcp_simple_resource"]
32 | 
33 | [tool.pyright]
34 | include = ["mcp_simple_resource"]
35 | venvPath = "."
36 | venv = ".venv"
37 | 
38 | [tool.ruff.lint]
39 | select = ["E", "F", "I"]
40 | ignore = []
41 | 
42 | [tool.ruff]
43 | line-length = 88
44 | target-version = "py310"
45 | 
46 | [tool.uv]
47 | dev-dependencies = ["pyright>=1.1.378", "pytest>=8.3.3", "ruff>=0.6.9"]
48 | 


--------------------------------------------------------------------------------
/examples/servers/simple-tool/.python-version:
--------------------------------------------------------------------------------
1 | 3.10
2 | 


--------------------------------------------------------------------------------
/examples/servers/simple-tool/README.md:
--------------------------------------------------------------------------------
 1 | 
 2 | A simple MCP server that exposes a website fetching tool.
 3 | 
 4 | ## Usage
 5 | 
 6 | Start the server using either stdio (default) or SSE transport:
 7 | 
 8 | ```bash
 9 | # Using stdio transport (default)
10 | uv run mcp-simple-tool
11 | 
12 | # Using SSE transport on custom port
13 | uv run mcp-simple-tool --transport sse --port 8000
14 | ```
15 | 
16 | The server exposes a tool named "fetch" that accepts one required argument:
17 | 
18 | - `url`: The URL of the website to fetch
19 | 
20 | ## Example
21 | 
22 | Using the MCP client, you can use the tool like this using the STDIO transport:
23 | 
24 | ```python
25 | import asyncio
26 | from mcp.client.session import ClientSession
27 | from mcp.client.stdio import StdioServerParameters, stdio_client
28 | 
29 | 
30 | async def main():
31 |     async with stdio_client(
32 |         StdioServerParameters(command="uv", args=["run", "mcp-simple-tool"])
33 |     ) as (read, write):
34 |         async with ClientSession(read, write) as session:
35 |             await session.initialize()
36 | 
37 |             # List available tools
38 |             tools = await session.list_tools()
39 |             print(tools)
40 | 
41 |             # Call the fetch tool
42 |             result = await session.call_tool("fetch", {"url": "https://example.com"})
43 |             print(result)
44 | 
45 | 
46 | asyncio.run(main())
47 | 
48 | ```
49 | 


--------------------------------------------------------------------------------
/examples/servers/simple-tool/mcp_simple_tool/__init__.py:
--------------------------------------------------------------------------------
1 | 
2 | 


--------------------------------------------------------------------------------
/examples/servers/simple-tool/mcp_simple_tool/__main__.py:
--------------------------------------------------------------------------------
1 | import sys
2 | 
3 | from server import main
4 | 
5 | sys.exit(main())
6 | 


--------------------------------------------------------------------------------
/examples/servers/simple-tool/mcp_simple_tool/server.py:
--------------------------------------------------------------------------------
  1 | import anyio
  2 | import click
  3 | import httpx
  4 | import mcp.types as types
  5 | from mcp.server import Server
  6 | 
  7 | 
  8 | async def fetch_website(
  9 |     url: str,
 10 | ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
 11 |     headers = {
 12 |         "User-Agent": "MCP Test Server (github.com/modelcontextprotocol/python-sdk)"
 13 |     }
 14 |     async with httpx.AsyncClient(follow_redirects=True, headers=headers) as client:
 15 |         response = await client.get(url)
 16 |         response.raise_for_status()
 17 |         return [types.TextContent(type="text", text=response.text)]
 18 | 
 19 | 
 20 | @click.command()
 21 | @click.option("--port", default=8000, help="Port to listen on for SSE")
 22 | @click.option(
 23 |     "--transport",
 24 |     type=click.Choice(["stdio", "sse"]),
 25 |     default="stdio",
 26 |     help="Transport type",
 27 | )
 28 | def main(port: int, transport: str) -> int:
 29 |     app = Server("mcp-website-fetcher")
 30 | 
 31 |     @app.call_tool()
 32 |     async def fetch_tool(
 33 |         name: str, arguments: dict
 34 |     ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
 35 |         if name != "fetch":
 36 |             raise ValueError(f"Unknown tool: {name}")
 37 |         if "url" not in arguments:
 38 |             raise ValueError("Missing required argument 'url'")
 39 |         return await fetch_website(arguments["url"])
 40 | 
 41 |     @app.list_tools()
 42 |     async def list_tools() -> list[types.Tool]:
 43 |         return [
 44 |             types.Tool(
 45 |                 name="fetch",
 46 |                 description="Fetches a website and returns its content",
 47 |                 inputSchema={
 48 |                     "type": "object",
 49 |                     "required": ["url"],
 50 |                     "properties": {
 51 |                         "url": {
 52 |                             "type": "string",
 53 |                             "description": "URL to fetch",
 54 |                         }
 55 |                     },
 56 |                 },
 57 |             )
 58 |         ]
 59 | 
 60 |     if transport == "sse":
 61 |         from mcp.server.sse import SseServerTransport
 62 |         from starlette.applications import Starlette
 63 |         from starlette.routing import Route
 64 | 
 65 |         sse = SseServerTransport("/messages")
 66 | 
 67 |         async def handle_sse(request):
 68 |             async with sse.connect_sse(
 69 |                 request.scope, request.receive, request._send
 70 |             ) as streams:
 71 |                 await app.run(
 72 |                     streams[0], streams[1], app.create_initialization_options()
 73 |                 )
 74 | 
 75 |         async def handle_messages(request):
 76 |             await sse.handle_post_message(request.scope, request.receive, request._send)
 77 | 
 78 |         starlette_app = Starlette(
 79 |             debug=True,
 80 |             routes=[
 81 |                 Route("/sse", endpoint=handle_sse),
 82 |                 Route("/messages", endpoint=handle_messages, methods=["POST"]),
 83 |             ],
 84 |         )
 85 | 
 86 |         import uvicorn
 87 | 
 88 |         uvicorn.run(starlette_app, host="0.0.0.0", port=port)
 89 |     else:
 90 |         from mcp.server.stdio import stdio_server
 91 | 
 92 |         async def arun():
 93 |             async with stdio_server() as streams:
 94 |                 await app.run(
 95 |                     streams[0], streams[1], app.create_initialization_options()
 96 |                 )
 97 | 
 98 |         anyio.run(arun)
 99 | 
100 |     return 0
101 | 


--------------------------------------------------------------------------------
/examples/servers/simple-tool/pyproject.toml:
--------------------------------------------------------------------------------
 1 | [project]
 2 | name = "mcp-simple-tool"
 3 | version = "0.1.0"
 4 | description = "A simple MCP server exposing a website fetching tool"
 5 | readme = "README.md"
 6 | requires-python = ">=3.10"
 7 | authors = [{ name = "Anthropic, PBC." }]
 8 | maintainers = [
 9 |     { name = "David Soria Parra", email = "davidsp@anthropic.com" },
10 |     { name = "Justin Spahr-Summers", email = "justin@anthropic.com" },
11 | ]
12 | keywords = ["mcp", "llm", "automation", "web", "fetch"]
13 | license = { text = "MIT" }
14 | classifiers = [
15 |     "Development Status :: 4 - Beta",
16 |     "Intended Audience :: Developers",
17 |     "License :: OSI Approved :: MIT License",
18 |     "Programming Language :: Python :: 3",
19 |     "Programming Language :: Python :: 3.10",
20 | ]
21 | dependencies = ["anyio>=4.5", "click>=8.1.0", "httpx>=0.27", "mcp"]
22 | 
23 | [project.scripts]
24 | mcp-simple-tool = "mcp_simple_tool.server:main"
25 | 
26 | [build-system]
27 | requires = ["hatchling"]
28 | build-backend = "hatchling.build"
29 | 
30 | [tool.hatch.build.targets.wheel]
31 | packages = ["mcp_simple_tool"]
32 | 
33 | [tool.pyright]
34 | include = ["mcp_simple_tool"]
35 | venvPath = "."
36 | venv = ".venv"
37 | 
38 | [tool.ruff.lint]
39 | select = ["E", "F", "I"]
40 | ignore = []
41 | 
42 | [tool.ruff]
43 | line-length = 88
44 | target-version = "py310"
45 | 
46 | [tool.uv]
47 | dev-dependencies = ["pyright>=1.1.378", "pytest>=8.3.3", "ruff>=0.6.9"]
48 | 


--------------------------------------------------------------------------------
/pyproject.toml:
--------------------------------------------------------------------------------
 1 | [build-system]
 2 | requires = ["hatchling"]
 3 | build-backend = "hatchling.build"
 4 | 
 5 | [project]
 6 | name = "mcp"
 7 | version = "1.1.1.dev0"
 8 | description = "Model Context Protocol SDK"
 9 | readme = "README.md"
10 | requires-python = ">=3.10"
11 | authors = [{ name = "Anthropic, PBC." }]
12 | maintainers = [
13 |     { name = "David Soria Parra", email = "davidsp@anthropic.com" },
14 |     { name = "Justin Spahr-Summers", email = "justin@anthropic.com" },
15 | ]
16 | keywords = ["git", "mcp", "llm", "automation"]
17 | license = { text = "MIT" }
18 | classifiers = [
19 |     "Development Status :: 4 - Beta",
20 |     "Intended Audience :: Developers",
21 |     "License :: OSI Approved :: MIT License",
22 |     "Programming Language :: Python :: 3",
23 |     "Programming Language :: Python :: 3.10",
24 |     "Programming Language :: Python :: 3.11",
25 |     "Programming Language :: Python :: 3.12",
26 |     "Programming Language :: Python :: 3.13",
27 | ]
28 | dependencies = [
29 |     "anyio>=4.5",
30 |     "httpx>=0.27",
31 |     "httpx-sse>=0.4",
32 |     "pydantic>=2.7.2",
33 |     "starlette>=0.27",
34 |     "sse-starlette>=2.0",
35 | ]
36 | 
37 | [project.urls]
38 | Homepage = "https://modelcontextprotocol.io"
39 | Repository = "https://github.com/modelcontextprotocol/python-sdk"
40 | Issues = "https://github.com/modelcontextprotocol/python-sdk/issues"
41 | 
42 | [tool.hatch.build.targets.wheel]
43 | packages = ["src/mcp"]
44 | 
45 | [tool.pyright]
46 | include = ["src/mcp", "tests"]
47 | venvPath = "."
48 | venv = ".venv"
49 | 
50 | [tool.ruff.lint]
51 | select = ["E", "F", "I"]
52 | ignore = []
53 | 
54 | [tool.ruff]
55 | line-length = 88
56 | target-version = "py310"
57 | 
58 | [tool.ruff.lint.per-file-ignores]
59 | "__init__.py" = ["F401"]
60 | 
61 | [tool.uv]
62 | resolution = "lowest-direct"
63 | dev-dependencies = [
64 |     "pyright>=1.1.378",
65 |     "pytest>=8.3.3",
66 |     "ruff>=0.6.9",
67 |     "trio>=0.26.2",
68 | ]
69 | 
70 | [tool.uv.workspace]
71 | members = ["examples/servers/*"]
72 | 
73 | [tool.uv.sources]
74 | mcp = { workspace = true }
75 | 


--------------------------------------------------------------------------------
/src/mcp/__init__.py:
--------------------------------------------------------------------------------
  1 | from .client.session import ClientSession
  2 | from .client.stdio import StdioServerParameters, stdio_client
  3 | from .server.session import ServerSession
  4 | from .server.stdio import stdio_server
  5 | from .shared.exceptions import McpError
  6 | from .types import (
  7 |     CallToolRequest,
  8 |     ClientCapabilities,
  9 |     ClientNotification,
 10 |     ClientRequest,
 11 |     ClientResult,
 12 |     CompleteRequest,
 13 |     CreateMessageRequest,
 14 |     CreateMessageResult,
 15 |     ErrorData,
 16 |     GetPromptRequest,
 17 |     GetPromptResult,
 18 |     Implementation,
 19 |     IncludeContext,
 20 |     InitializedNotification,
 21 |     InitializeRequest,
 22 |     InitializeResult,
 23 |     JSONRPCError,
 24 |     JSONRPCRequest,
 25 |     JSONRPCResponse,
 26 |     ListPromptsRequest,
 27 |     ListPromptsResult,
 28 |     ListResourcesRequest,
 29 |     ListResourcesResult,
 30 |     ListToolsResult,
 31 |     LoggingLevel,
 32 |     LoggingMessageNotification,
 33 |     Notification,
 34 |     PingRequest,
 35 |     ProgressNotification,
 36 |     PromptsCapability,
 37 |     ReadResourceRequest,
 38 |     ReadResourceResult,
 39 |     Resource,
 40 |     ResourcesCapability,
 41 |     ResourceUpdatedNotification,
 42 |     RootsCapability,
 43 |     SamplingMessage,
 44 |     ServerCapabilities,
 45 |     ServerNotification,
 46 |     ServerRequest,
 47 |     ServerResult,
 48 |     SetLevelRequest,
 49 |     StopReason,
 50 |     SubscribeRequest,
 51 |     Tool,
 52 |     ToolsCapability,
 53 |     UnsubscribeRequest,
 54 | )
 55 | from .types import (
 56 |     Role as SamplingRole,
 57 | )
 58 | 
 59 | __all__ = [
 60 |     "CallToolRequest",
 61 |     "ClientCapabilities",
 62 |     "ClientNotification",
 63 |     "ClientRequest",
 64 |     "ClientResult",
 65 |     "ClientSession",
 66 |     "CreateMessageRequest",
 67 |     "CreateMessageResult",
 68 |     "ErrorData",
 69 |     "GetPromptRequest",
 70 |     "GetPromptResult",
 71 |     "Implementation",
 72 |     "IncludeContext",
 73 |     "InitializeRequest",
 74 |     "InitializeResult",
 75 |     "InitializedNotification",
 76 |     "JSONRPCError",
 77 |     "JSONRPCRequest",
 78 |     "ListPromptsRequest",
 79 |     "ListPromptsResult",
 80 |     "ListResourcesRequest",
 81 |     "ListResourcesResult",
 82 |     "ListToolsResult",
 83 |     "LoggingLevel",
 84 |     "LoggingMessageNotification",
 85 |     "McpError",
 86 |     "Notification",
 87 |     "PingRequest",
 88 |     "ProgressNotification",
 89 |     "PromptsCapability",
 90 |     "ReadResourceRequest",
 91 |     "ReadResourceResult",
 92 |     "ResourcesCapability",
 93 |     "ResourceUpdatedNotification",
 94 |     "Resource",
 95 |     "RootsCapability",
 96 |     "SamplingMessage",
 97 |     "SamplingRole",
 98 |     "ServerCapabilities",
 99 |     "ServerNotification",
100 |     "ServerRequest",
101 |     "ServerResult",
102 |     "ServerSession",
103 |     "SetLevelRequest",
104 |     "StdioServerParameters",
105 |     "StopReason",
106 |     "SubscribeRequest",
107 |     "Tool",
108 |     "ToolsCapability",
109 |     "UnsubscribeRequest",
110 |     "stdio_client",
111 |     "stdio_server",
112 |     "CompleteRequest",
113 |     "JSONRPCResponse",
114 | ]
115 | 


--------------------------------------------------------------------------------
/src/mcp/client/__init__.py:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/aaf32b530738ff79ba607c2884374243350f521c/src/mcp/client/__init__.py


--------------------------------------------------------------------------------
/src/mcp/client/__main__.py:
--------------------------------------------------------------------------------
 1 | import logging
 2 | import sys
 3 | from functools import partial
 4 | from urllib.parse import urlparse
 5 | 
 6 | import anyio
 7 | import click
 8 | 
 9 | from mcp.client.session import ClientSession
10 | from mcp.client.sse import sse_client
11 | from mcp.client.stdio import StdioServerParameters, stdio_client
12 | 
13 | if not sys.warnoptions:
14 |     import warnings
15 | 
16 |     warnings.simplefilter("ignore")
17 | 
18 | logging.basicConfig(level=logging.INFO)
19 | logger = logging.getLogger("client")
20 | 
21 | 
22 | async def receive_loop(session: ClientSession):
23 |     logger.info("Starting receive loop")
24 |     async for message in session.incoming_messages:
25 |         if isinstance(message, Exception):
26 |             logger.error("Error: %s", message)
27 |             continue
28 | 
29 |         logger.info("Received message from server: %s", message)
30 | 
31 | 
32 | async def run_session(read_stream, write_stream):
33 |     async with (
34 |         ClientSession(read_stream, write_stream) as session,
35 |         anyio.create_task_group() as tg,
36 |     ):
37 |         tg.start_soon(receive_loop, session)
38 | 
39 |         logger.info("Initializing session")
40 |         await session.initialize()
41 |         logger.info("Initialized")
42 | 
43 | 
44 | async def main(command_or_url: str, args: list[str], env: list[tuple[str, str]]):
45 |     env_dict = dict(env)
46 | 
47 |     if urlparse(command_or_url).scheme in ("http", "https"):
48 |         # Use SSE client for HTTP(S) URLs
49 |         async with sse_client(command_or_url) as streams:
50 |             await run_session(*streams)
51 |     else:
52 |         # Use stdio client for commands
53 |         server_parameters = StdioServerParameters(
54 |             command=command_or_url, args=args, env=env_dict
55 |         )
56 |         async with stdio_client(server_parameters) as streams:
57 |             await run_session(*streams)
58 | 
59 | 
60 | @click.command()
61 | @click.argument("command_or_url")
62 | @click.argument("args", nargs=-1)
63 | @click.option(
64 |     "--env",
65 |     "-e",
66 |     multiple=True,
67 |     nargs=2,
68 |     metavar="KEY VALUE",
69 |     help="Environment variables to set. Can be used multiple times.",
70 | )
71 | def cli(*args, **kwargs):
72 |     anyio.run(partial(main, *args, **kwargs), backend="trio")
73 | 
74 | 
75 | if __name__ == "__main__":
76 |     cli()
77 | 


--------------------------------------------------------------------------------
/src/mcp/client/session.py:
--------------------------------------------------------------------------------
  1 | from datetime import timedelta
  2 | 
  3 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
  4 | from pydantic import AnyUrl
  5 | 
  6 | import mcp.types as types
  7 | from mcp.shared.session import BaseSession
  8 | from mcp.shared.version import SUPPORTED_PROTOCOL_VERSIONS
  9 | 
 10 | 
 11 | class ClientSession(
 12 |     BaseSession[
 13 |         types.ClientRequest,
 14 |         types.ClientNotification,
 15 |         types.ClientResult,
 16 |         types.ServerRequest,
 17 |         types.ServerNotification,
 18 |     ]
 19 | ):
 20 |     def __init__(
 21 |         self,
 22 |         read_stream: MemoryObjectReceiveStream[types.JSONRPCMessage | Exception],
 23 |         write_stream: MemoryObjectSendStream[types.JSONRPCMessage],
 24 |         read_timeout_seconds: timedelta | None = None,
 25 |     ) -> None:
 26 |         super().__init__(
 27 |             read_stream,
 28 |             write_stream,
 29 |             types.ServerRequest,
 30 |             types.ServerNotification,
 31 |             read_timeout_seconds=read_timeout_seconds,
 32 |         )
 33 | 
 34 |     async def initialize(self) -> types.InitializeResult:
 35 |         result = await self.send_request(
 36 |             types.ClientRequest(
 37 |                 types.InitializeRequest(
 38 |                     method="initialize",
 39 |                     params=types.InitializeRequestParams(
 40 |                         protocolVersion=types.LATEST_PROTOCOL_VERSION,
 41 |                         capabilities=types.ClientCapabilities(
 42 |                             sampling=None,
 43 |                             experimental=None,
 44 |                             roots=types.RootsCapability(
 45 |                                 # TODO: Should this be based on whether we
 46 |                                 # _will_ send notifications, or only whether
 47 |                                 # they're supported?
 48 |                                 listChanged=True
 49 |                             ),
 50 |                         ),
 51 |                         clientInfo=types.Implementation(name="mcp", version="0.1.0"),
 52 |                     ),
 53 |                 )
 54 |             ),
 55 |             types.InitializeResult,
 56 |         )
 57 | 
 58 |         if result.protocolVersion not in SUPPORTED_PROTOCOL_VERSIONS:
 59 |             raise RuntimeError(
 60 |                 "Unsupported protocol version from the server: "
 61 |                 f"{result.protocolVersion}"
 62 |             )
 63 | 
 64 |         await self.send_notification(
 65 |             types.ClientNotification(
 66 |                 types.InitializedNotification(method="notifications/initialized")
 67 |             )
 68 |         )
 69 | 
 70 |         return result
 71 | 
 72 |     async def send_ping(self) -> types.EmptyResult:
 73 |         """Send a ping request."""
 74 |         return await self.send_request(
 75 |             types.ClientRequest(
 76 |                 types.PingRequest(
 77 |                     method="ping",
 78 |                 )
 79 |             ),
 80 |             types.EmptyResult,
 81 |         )
 82 | 
 83 |     async def send_progress_notification(
 84 |         self, progress_token: str | int, progress: float, total: float | None = None
 85 |     ) -> None:
 86 |         """Send a progress notification."""
 87 |         await self.send_notification(
 88 |             types.ClientNotification(
 89 |                 types.ProgressNotification(
 90 |                     method="notifications/progress",
 91 |                     params=types.ProgressNotificationParams(
 92 |                         progressToken=progress_token,
 93 |                         progress=progress,
 94 |                         total=total,
 95 |                     ),
 96 |                 ),
 97 |             )
 98 |         )
 99 | 
100 |     async def set_logging_level(self, level: types.LoggingLevel) -> types.EmptyResult:
101 |         """Send a logging/setLevel request."""
102 |         return await self.send_request(
103 |             types.ClientRequest(
104 |                 types.SetLevelRequest(
105 |                     method="logging/setLevel",
106 |                     params=types.SetLevelRequestParams(level=level),
107 |                 )
108 |             ),
109 |             types.EmptyResult,
110 |         )
111 | 
112 |     async def list_resources(self) -> types.ListResourcesResult:
113 |         """Send a resources/list request."""
114 |         return await self.send_request(
115 |             types.ClientRequest(
116 |                 types.ListResourcesRequest(
117 |                     method="resources/list",
118 |                 )
119 |             ),
120 |             types.ListResourcesResult,
121 |         )
122 | 
123 |     async def read_resource(self, uri: AnyUrl) -> types.ReadResourceResult:
124 |         """Send a resources/read request."""
125 |         return await self.send_request(
126 |             types.ClientRequest(
127 |                 types.ReadResourceRequest(
128 |                     method="resources/read",
129 |                     params=types.ReadResourceRequestParams(uri=uri),
130 |                 )
131 |             ),
132 |             types.ReadResourceResult,
133 |         )
134 | 
135 |     async def subscribe_resource(self, uri: AnyUrl) -> types.EmptyResult:
136 |         """Send a resources/subscribe request."""
137 |         return await self.send_request(
138 |             types.ClientRequest(
139 |                 types.SubscribeRequest(
140 |                     method="resources/subscribe",
141 |                     params=types.SubscribeRequestParams(uri=uri),
142 |                 )
143 |             ),
144 |             types.EmptyResult,
145 |         )
146 | 
147 |     async def unsubscribe_resource(self, uri: AnyUrl) -> types.EmptyResult:
148 |         """Send a resources/unsubscribe request."""
149 |         return await self.send_request(
150 |             types.ClientRequest(
151 |                 types.UnsubscribeRequest(
152 |                     method="resources/unsubscribe",
153 |                     params=types.UnsubscribeRequestParams(uri=uri),
154 |                 )
155 |             ),
156 |             types.EmptyResult,
157 |         )
158 | 
159 |     async def call_tool(
160 |         self, name: str, arguments: dict | None = None
161 |     ) -> types.CallToolResult:
162 |         """Send a tools/call request."""
163 |         return await self.send_request(
164 |             types.ClientRequest(
165 |                 types.CallToolRequest(
166 |                     method="tools/call",
167 |                     params=types.CallToolRequestParams(name=name, arguments=arguments),
168 |                 )
169 |             ),
170 |             types.CallToolResult,
171 |         )
172 | 
173 |     async def list_prompts(self) -> types.ListPromptsResult:
174 |         """Send a prompts/list request."""
175 |         return await self.send_request(
176 |             types.ClientRequest(
177 |                 types.ListPromptsRequest(
178 |                     method="prompts/list",
179 |                 )
180 |             ),
181 |             types.ListPromptsResult,
182 |         )
183 | 
184 |     async def get_prompt(
185 |         self, name: str, arguments: dict[str, str] | None = None
186 |     ) -> types.GetPromptResult:
187 |         """Send a prompts/get request."""
188 |         return await self.send_request(
189 |             types.ClientRequest(
190 |                 types.GetPromptRequest(
191 |                     method="prompts/get",
192 |                     params=types.GetPromptRequestParams(name=name, arguments=arguments),
193 |                 )
194 |             ),
195 |             types.GetPromptResult,
196 |         )
197 | 
198 |     async def complete(
199 |         self, ref: types.ResourceReference | types.PromptReference, argument: dict
200 |     ) -> types.CompleteResult:
201 |         """Send a completion/complete request."""
202 |         return await self.send_request(
203 |             types.ClientRequest(
204 |                 types.CompleteRequest(
205 |                     method="completion/complete",
206 |                     params=types.CompleteRequestParams(
207 |                         ref=ref,
208 |                         argument=types.CompletionArgument(**argument),
209 |                     ),
210 |                 )
211 |             ),
212 |             types.CompleteResult,
213 |         )
214 | 
215 |     async def list_tools(self) -> types.ListToolsResult:
216 |         """Send a tools/list request."""
217 |         return await self.send_request(
218 |             types.ClientRequest(
219 |                 types.ListToolsRequest(
220 |                     method="tools/list",
221 |                 )
222 |             ),
223 |             types.ListToolsResult,
224 |         )
225 | 
226 |     async def send_roots_list_changed(self) -> None:
227 |         """Send a roots/list_changed notification."""
228 |         await self.send_notification(
229 |             types.ClientNotification(
230 |                 types.RootsListChangedNotification(
231 |                     method="notifications/roots/list_changed",
232 |                 )
233 |             )
234 |         )
235 | 


--------------------------------------------------------------------------------
/src/mcp/client/sse.py:
--------------------------------------------------------------------------------
  1 | import logging
  2 | from contextlib import asynccontextmanager
  3 | from typing import Any
  4 | from urllib.parse import urljoin, urlparse
  5 | 
  6 | import anyio
  7 | import httpx
  8 | from anyio.abc import TaskStatus
  9 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
 10 | from httpx_sse import aconnect_sse
 11 | 
 12 | import mcp.types as types
 13 | 
 14 | logger = logging.getLogger(__name__)
 15 | 
 16 | 
 17 | def remove_request_params(url: str) -> str:
 18 |     return urljoin(url, urlparse(url).path)
 19 | 
 20 | 
 21 | @asynccontextmanager
 22 | async def sse_client(
 23 |     url: str,
 24 |     headers: dict[str, Any] | None = None,
 25 |     timeout: float = 5,
 26 |     sse_read_timeout: float = 60 * 5,
 27 | ):
 28 |     """
 29 |     Client transport for SSE.
 30 | 
 31 |     `sse_read_timeout` determines how long (in seconds) the client will wait for a new
 32 |     event before disconnecting. All other HTTP operations are controlled by `timeout`.
 33 |     """
 34 |     read_stream: MemoryObjectReceiveStream[types.JSONRPCMessage | Exception]
 35 |     read_stream_writer: MemoryObjectSendStream[types.JSONRPCMessage | Exception]
 36 | 
 37 |     write_stream: MemoryObjectSendStream[types.JSONRPCMessage]
 38 |     write_stream_reader: MemoryObjectReceiveStream[types.JSONRPCMessage]
 39 | 
 40 |     read_stream_writer, read_stream = anyio.create_memory_object_stream(0)
 41 |     write_stream, write_stream_reader = anyio.create_memory_object_stream(0)
 42 | 
 43 |     async with anyio.create_task_group() as tg:
 44 |         try:
 45 |             logger.info(f"Connecting to SSE endpoint: {remove_request_params(url)}")
 46 |             async with httpx.AsyncClient(headers=headers) as client:
 47 |                 async with aconnect_sse(
 48 |                     client,
 49 |                     "GET",
 50 |                     url,
 51 |                     timeout=httpx.Timeout(timeout, read=sse_read_timeout),
 52 |                 ) as event_source:
 53 |                     event_source.response.raise_for_status()
 54 |                     logger.debug("SSE connection established")
 55 | 
 56 |                     async def sse_reader(
 57 |                         task_status: TaskStatus[str] = anyio.TASK_STATUS_IGNORED,
 58 |                     ):
 59 |                         try:
 60 |                             async for sse in event_source.aiter_sse():
 61 |                                 logger.debug(f"Received SSE event: {sse.event}")
 62 |                                 match sse.event:
 63 |                                     case "endpoint":
 64 |                                         endpoint_url = urljoin(url, sse.data)
 65 |                                         logger.info(
 66 |                                             f"Received endpoint URL: {endpoint_url}"
 67 |                                         )
 68 | 
 69 |                                         url_parsed = urlparse(url)
 70 |                                         endpoint_parsed = urlparse(endpoint_url)
 71 |                                         if (
 72 |                                             url_parsed.netloc != endpoint_parsed.netloc
 73 |                                             or url_parsed.scheme
 74 |                                             != endpoint_parsed.scheme
 75 |                                         ):
 76 |                                             error_msg = (
 77 |                                                 "Endpoint origin does not match "
 78 |                                                 f"connection origin: {endpoint_url}"
 79 |                                             )
 80 |                                             logger.error(error_msg)
 81 |                                             raise ValueError(error_msg)
 82 | 
 83 |                                         task_status.started(endpoint_url)
 84 | 
 85 |                                     case "message":
 86 |                                         try:
 87 |                                             message = types.JSONRPCMessage.model_validate_json(  # noqa: E501
 88 |                                                 sse.data
 89 |                                             )
 90 |                                             logger.debug(
 91 |                                                 f"Received server message: {message}"
 92 |                                             )
 93 |                                         except Exception as exc:
 94 |                                             logger.error(
 95 |                                                 f"Error parsing server message: {exc}"
 96 |                                             )
 97 |                                             await read_stream_writer.send(exc)
 98 |                                             continue
 99 | 
100 |                                         await read_stream_writer.send(message)
101 |                         except Exception as exc:
102 |                             logger.error(f"Error in sse_reader: {exc}")
103 |                             await read_stream_writer.send(exc)
104 |                         finally:
105 |                             await read_stream_writer.aclose()
106 | 
107 |                     async def post_writer(endpoint_url: str):
108 |                         try:
109 |                             async with write_stream_reader:
110 |                                 async for message in write_stream_reader:
111 |                                     logger.debug(f"Sending client message: {message}")
112 |                                     response = await client.post(
113 |                                         endpoint_url,
114 |                                         json=message.model_dump(
115 |                                             by_alias=True,
116 |                                             mode="json",
117 |                                             exclude_none=True,
118 |                                         ),
119 |                                     )
120 |                                     response.raise_for_status()
121 |                                     logger.debug(
122 |                                         "Client message sent successfully: "
123 |                                         f"{response.status_code}"
124 |                                     )
125 |                         except Exception as exc:
126 |                             logger.error(f"Error in post_writer: {exc}")
127 |                         finally:
128 |                             await write_stream.aclose()
129 | 
130 |                     endpoint_url = await tg.start(sse_reader)
131 |                     logger.info(
132 |                         f"Starting post writer with endpoint URL: {endpoint_url}"
133 |                     )
134 |                     tg.start_soon(post_writer, endpoint_url)
135 | 
136 |                     try:
137 |                         yield read_stream, write_stream
138 |                     finally:
139 |                         tg.cancel_scope.cancel()
140 |         finally:
141 |             await read_stream_writer.aclose()
142 |             await write_stream.aclose()
143 | 


--------------------------------------------------------------------------------
/src/mcp/client/stdio.py:
--------------------------------------------------------------------------------
  1 | import os
  2 | import sys
  3 | from contextlib import asynccontextmanager
  4 | 
  5 | import anyio
  6 | import anyio.lowlevel
  7 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
  8 | from anyio.streams.text import TextReceiveStream
  9 | from pydantic import BaseModel, Field
 10 | 
 11 | import mcp.types as types
 12 | 
 13 | # Environment variables to inherit by default
 14 | DEFAULT_INHERITED_ENV_VARS = (
 15 |     [
 16 |         "APPDATA",
 17 |         "HOMEDRIVE",
 18 |         "HOMEPATH",
 19 |         "LOCALAPPDATA",
 20 |         "PATH",
 21 |         "PROCESSOR_ARCHITECTURE",
 22 |         "SYSTEMDRIVE",
 23 |         "SYSTEMROOT",
 24 |         "TEMP",
 25 |         "USERNAME",
 26 |         "USERPROFILE",
 27 |     ]
 28 |     if sys.platform == "win32"
 29 |     else ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"]
 30 | )
 31 | 
 32 | 
 33 | def get_default_environment() -> dict[str, str]:
 34 |     """
 35 |     Returns a default environment object including only environment variables deemed
 36 |     safe to inherit.
 37 |     """
 38 |     env: dict[str, str] = {}
 39 | 
 40 |     for key in DEFAULT_INHERITED_ENV_VARS:
 41 |         value = os.environ.get(key)
 42 |         if value is None:
 43 |             continue
 44 | 
 45 |         if value.startswith("()"):
 46 |             # Skip functions, which are a security risk
 47 |             continue
 48 | 
 49 |         env[key] = value
 50 | 
 51 |     return env
 52 | 
 53 | 
 54 | class StdioServerParameters(BaseModel):
 55 |     command: str
 56 |     """The executable to run to start the server."""
 57 | 
 58 |     args: list[str] = Field(default_factory=list)
 59 |     """Command line arguments to pass to the executable."""
 60 | 
 61 |     env: dict[str, str] | None = None
 62 |     """
 63 |     The environment to use when spawning the process.
 64 | 
 65 |     If not specified, the result of get_default_environment() will be used.
 66 |     """
 67 | 
 68 | 
 69 | @asynccontextmanager
 70 | async def stdio_client(server: StdioServerParameters):
 71 |     """
 72 |     Client transport for stdio: this will connect to a server by spawning a
 73 |     process and communicating with it over stdin/stdout.
 74 |     """
 75 |     read_stream: MemoryObjectReceiveStream[types.JSONRPCMessage | Exception]
 76 |     read_stream_writer: MemoryObjectSendStream[types.JSONRPCMessage | Exception]
 77 | 
 78 |     write_stream: MemoryObjectSendStream[types.JSONRPCMessage]
 79 |     write_stream_reader: MemoryObjectReceiveStream[types.JSONRPCMessage]
 80 | 
 81 |     read_stream_writer, read_stream = anyio.create_memory_object_stream(0)
 82 |     write_stream, write_stream_reader = anyio.create_memory_object_stream(0)
 83 | 
 84 |     process = await anyio.open_process(
 85 |         [server.command, *server.args],
 86 |         env=server.env if server.env is not None else get_default_environment(),
 87 |         stderr=sys.stderr,
 88 |     )
 89 | 
 90 |     async def stdout_reader():
 91 |         assert process.stdout, "Opened process is missing stdout"
 92 | 
 93 |         try:
 94 |             async with read_stream_writer:
 95 |                 buffer = ""
 96 |                 async for chunk in TextReceiveStream(process.stdout):
 97 |                     lines = (buffer + chunk).split("\n")
 98 |                     buffer = lines.pop()
 99 | 
100 |                     for line in lines:
101 |                         try:
102 |                             message = types.JSONRPCMessage.model_validate_json(line)
103 |                         except Exception as exc:
104 |                             await read_stream_writer.send(exc)
105 |                             continue
106 | 
107 |                         await read_stream_writer.send(message)
108 |         except anyio.ClosedResourceError:
109 |             await anyio.lowlevel.checkpoint()
110 | 
111 |     async def stdin_writer():
112 |         assert process.stdin, "Opened process is missing stdin"
113 | 
114 |         try:
115 |             async with write_stream_reader:
116 |                 async for message in write_stream_reader:
117 |                     json = message.model_dump_json(by_alias=True, exclude_none=True)
118 |                     await process.stdin.send((json + "\n").encode())
119 |         except anyio.ClosedResourceError:
120 |             await anyio.lowlevel.checkpoint()
121 | 
122 |     async with (
123 |         anyio.create_task_group() as tg,
124 |         process,
125 |     ):
126 |         tg.start_soon(stdout_reader)
127 |         tg.start_soon(stdin_writer)
128 |         yield read_stream, write_stream
129 | 


--------------------------------------------------------------------------------
/src/mcp/py.typed:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/aaf32b530738ff79ba607c2884374243350f521c/src/mcp/py.typed


--------------------------------------------------------------------------------
/src/mcp/server/__init__.py:
--------------------------------------------------------------------------------
  1 | """
  2 | MCP Server Module
  3 | 
  4 | This module provides a framework for creating an MCP (Model Context Protocol) server.
  5 | It allows you to easily define and handle various types of requests and notifications
  6 | in an asynchronous manner.
  7 | 
  8 | Usage:
  9 | 1. Create a Server instance:
 10 |    server = Server("your_server_name")
 11 | 
 12 | 2. Define request handlers using decorators:
 13 |    @server.list_prompts()
 14 |    async def handle_list_prompts() -> list[types.Prompt]:
 15 |        # Implementation
 16 | 
 17 |    @server.get_prompt()
 18 |    async def handle_get_prompt(
 19 |        name: str, arguments: dict[str, str] | None
 20 |    ) -> types.GetPromptResult:
 21 |        # Implementation
 22 | 
 23 |    @server.list_tools()
 24 |    async def handle_list_tools() -> list[types.Tool]:
 25 |        # Implementation
 26 | 
 27 |    @server.call_tool()
 28 |    async def handle_call_tool(
 29 |        name: str, arguments: dict | None
 30 |    ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
 31 |        # Implementation
 32 | 
 33 |    @server.list_resource_templates()
 34 |    async def handle_list_resource_templates() -> list[types.ResourceTemplate]:
 35 |        # Implementation
 36 | 
 37 | 3. Define notification handlers if needed:
 38 |    @server.progress_notification()
 39 |    async def handle_progress(
 40 |        progress_token: str | int, progress: float, total: float | None
 41 |    ) -> None:
 42 |        # Implementation
 43 | 
 44 | 4. Run the server:
 45 |    async def main():
 46 |        async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
 47 |            await server.run(
 48 |                read_stream,
 49 |                write_stream,
 50 |                InitializationOptions(
 51 |                    server_name="your_server_name",
 52 |                    server_version="your_version",
 53 |                    capabilities=server.get_capabilities(
 54 |                        notification_options=NotificationOptions(),
 55 |                        experimental_capabilities={},
 56 |                    ),
 57 |                ),
 58 |            )
 59 | 
 60 |    asyncio.run(main())
 61 | 
 62 | The Server class provides methods to register handlers for various MCP requests and
 63 | notifications. It automatically manages the request context and handles incoming
 64 | messages from the client.
 65 | """
 66 | 
 67 | import contextvars
 68 | import logging
 69 | import warnings
 70 | from collections.abc import Awaitable, Callable
 71 | from typing import Any, Sequence
 72 | 
 73 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
 74 | from pydantic import AnyUrl
 75 | 
 76 | import mcp.types as types
 77 | from mcp.server.models import InitializationOptions
 78 | from mcp.server.session import ServerSession
 79 | from mcp.server.stdio import stdio_server as stdio_server
 80 | from mcp.shared.context import RequestContext
 81 | from mcp.shared.exceptions import McpError
 82 | from mcp.shared.session import RequestResponder
 83 | 
 84 | logger = logging.getLogger(__name__)
 85 | 
 86 | request_ctx: contextvars.ContextVar[RequestContext[ServerSession]] = (
 87 |     contextvars.ContextVar("request_ctx")
 88 | )
 89 | 
 90 | 
 91 | class NotificationOptions:
 92 |     def __init__(
 93 |         self,
 94 |         prompts_changed: bool = False,
 95 |         resources_changed: bool = False,
 96 |         tools_changed: bool = False,
 97 |     ):
 98 |         self.prompts_changed = prompts_changed
 99 |         self.resources_changed = resources_changed
100 |         self.tools_changed = tools_changed
101 | 
102 | 
103 | class Server:
104 |     def __init__(self, name: str):
105 |         self.name = name
106 |         self.request_handlers: dict[
107 |             type, Callable[..., Awaitable[types.ServerResult]]
108 |         ] = {
109 |             types.PingRequest: _ping_handler,
110 |         }
111 |         self.notification_handlers: dict[type, Callable[..., Awaitable[None]]] = {}
112 |         self.notification_options = NotificationOptions()
113 |         logger.debug(f"Initializing server '{name}'")
114 | 
115 |     def create_initialization_options(
116 |         self,
117 |         notification_options: NotificationOptions | None = None,
118 |         experimental_capabilities: dict[str, dict[str, Any]] | None = None,
119 |     ) -> InitializationOptions:
120 |         """Create initialization options from this server instance."""
121 | 
122 |         def pkg_version(package: str) -> str:
123 |             try:
124 |                 from importlib.metadata import version
125 | 
126 |                 v = version(package)
127 |                 if v is not None:
128 |                     return v
129 |             except Exception:
130 |                 pass
131 | 
132 |             return "unknown"
133 | 
134 |         return InitializationOptions(
135 |             server_name=self.name,
136 |             server_version=pkg_version("mcp"),
137 |             capabilities=self.get_capabilities(
138 |                 notification_options or NotificationOptions(),
139 |                 experimental_capabilities or {},
140 |             ),
141 |         )
142 | 
143 |     def get_capabilities(
144 |         self,
145 |         notification_options: NotificationOptions,
146 |         experimental_capabilities: dict[str, dict[str, Any]],
147 |     ) -> types.ServerCapabilities:
148 |         """Convert existing handlers to a ServerCapabilities object."""
149 |         prompts_capability = None
150 |         resources_capability = None
151 |         tools_capability = None
152 |         logging_capability = None
153 | 
154 |         # Set prompt capabilities if handler exists
155 |         if types.ListPromptsRequest in self.request_handlers:
156 |             prompts_capability = types.PromptsCapability(
157 |                 listChanged=notification_options.prompts_changed
158 |             )
159 | 
160 |         # Set resource capabilities if handler exists
161 |         if types.ListResourcesRequest in self.request_handlers:
162 |             resources_capability = types.ResourcesCapability(
163 |                 subscribe=False, listChanged=notification_options.resources_changed
164 |             )
165 | 
166 |         # Set tool capabilities if handler exists
167 |         if types.ListToolsRequest in self.request_handlers:
168 |             tools_capability = types.ToolsCapability(
169 |                 listChanged=notification_options.tools_changed
170 |             )
171 | 
172 |         # Set logging capabilities if handler exists
173 |         if types.SetLevelRequest in self.request_handlers:
174 |             logging_capability = types.LoggingCapability()
175 | 
176 |         return types.ServerCapabilities(
177 |             prompts=prompts_capability,
178 |             resources=resources_capability,
179 |             tools=tools_capability,
180 |             logging=logging_capability,
181 |             experimental=experimental_capabilities,
182 |         )
183 | 
184 |     @property
185 |     def request_context(self) -> RequestContext[ServerSession]:
186 |         """If called outside of a request context, this will raise a LookupError."""
187 |         return request_ctx.get()
188 | 
189 |     def list_prompts(self):
190 |         def decorator(func: Callable[[], Awaitable[list[types.Prompt]]]):
191 |             logger.debug("Registering handler for PromptListRequest")
192 | 
193 |             async def handler(_: Any):
194 |                 prompts = await func()
195 |                 return types.ServerResult(types.ListPromptsResult(prompts=prompts))
196 | 
197 |             self.request_handlers[types.ListPromptsRequest] = handler
198 |             return func
199 | 
200 |         return decorator
201 | 
202 |     def get_prompt(self):
203 |         def decorator(
204 |             func: Callable[
205 |                 [str, dict[str, str] | None], Awaitable[types.GetPromptResult]
206 |             ],
207 |         ):
208 |             logger.debug("Registering handler for GetPromptRequest")
209 | 
210 |             async def handler(req: types.GetPromptRequest):
211 |                 prompt_get = await func(req.params.name, req.params.arguments)
212 |                 return types.ServerResult(prompt_get)
213 | 
214 |             self.request_handlers[types.GetPromptRequest] = handler
215 |             return func
216 | 
217 |         return decorator
218 | 
219 |     def list_resources(self):
220 |         def decorator(func: Callable[[], Awaitable[list[types.Resource]]]):
221 |             logger.debug("Registering handler for ListResourcesRequest")
222 | 
223 |             async def handler(_: Any):
224 |                 resources = await func()
225 |                 return types.ServerResult(
226 |                     types.ListResourcesResult(resources=resources)
227 |                 )
228 | 
229 |             self.request_handlers[types.ListResourcesRequest] = handler
230 |             return func
231 | 
232 |         return decorator
233 | 
234 |     def list_resource_templates(self):
235 |         def decorator(func: Callable[[], Awaitable[list[types.ResourceTemplate]]]):
236 |             logger.debug("Registering handler for ListResourceTemplatesRequest")
237 | 
238 |             async def handler(_: Any):
239 |                 templates = await func()
240 |                 return types.ServerResult(
241 |                     types.ListResourceTemplatesResult(resourceTemplates=templates)
242 |                 )
243 | 
244 |             self.request_handlers[types.ListResourceTemplatesRequest] = handler
245 |             return func
246 | 
247 |         return decorator
248 | 
249 |     def read_resource(self):
250 |         def decorator(func: Callable[[AnyUrl], Awaitable[str | bytes]]):
251 |             logger.debug("Registering handler for ReadResourceRequest")
252 | 
253 |             async def handler(req: types.ReadResourceRequest):
254 |                 result = await func(req.params.uri)
255 |                 match result:
256 |                     case str(s):
257 |                         content = types.TextResourceContents(
258 |                             uri=req.params.uri,
259 |                             text=s,
260 |                             mimeType="text/plain",
261 |                         )
262 |                     case bytes(b):
263 |                         import base64
264 | 
265 |                         content = types.BlobResourceContents(
266 |                             uri=req.params.uri,
267 |                             blob=base64.urlsafe_b64encode(b).decode(),
268 |                             mimeType="application/octet-stream",
269 |                         )
270 | 
271 |                 return types.ServerResult(
272 |                     types.ReadResourceResult(
273 |                         contents=[content],
274 |                     )
275 |                 )
276 | 
277 |             self.request_handlers[types.ReadResourceRequest] = handler
278 |             return func
279 | 
280 |         return decorator
281 | 
282 |     def set_logging_level(self):
283 |         def decorator(func: Callable[[types.LoggingLevel], Awaitable[None]]):
284 |             logger.debug("Registering handler for SetLevelRequest")
285 | 
286 |             async def handler(req: types.SetLevelRequest):
287 |                 await func(req.params.level)
288 |                 return types.ServerResult(types.EmptyResult())
289 | 
290 |             self.request_handlers[types.SetLevelRequest] = handler
291 |             return func
292 | 
293 |         return decorator
294 | 
295 |     def subscribe_resource(self):
296 |         def decorator(func: Callable[[AnyUrl], Awaitable[None]]):
297 |             logger.debug("Registering handler for SubscribeRequest")
298 | 
299 |             async def handler(req: types.SubscribeRequest):
300 |                 await func(req.params.uri)
301 |                 return types.ServerResult(types.EmptyResult())
302 | 
303 |             self.request_handlers[types.SubscribeRequest] = handler
304 |             return func
305 | 
306 |         return decorator
307 | 
308 |     def unsubscribe_resource(self):
309 |         def decorator(func: Callable[[AnyUrl], Awaitable[None]]):
310 |             logger.debug("Registering handler for UnsubscribeRequest")
311 | 
312 |             async def handler(req: types.UnsubscribeRequest):
313 |                 await func(req.params.uri)
314 |                 return types.ServerResult(types.EmptyResult())
315 | 
316 |             self.request_handlers[types.UnsubscribeRequest] = handler
317 |             return func
318 | 
319 |         return decorator
320 | 
321 |     def list_tools(self):
322 |         def decorator(func: Callable[[], Awaitable[list[types.Tool]]]):
323 |             logger.debug("Registering handler for ListToolsRequest")
324 | 
325 |             async def handler(_: Any):
326 |                 tools = await func()
327 |                 return types.ServerResult(types.ListToolsResult(tools=tools))
328 | 
329 |             self.request_handlers[types.ListToolsRequest] = handler
330 |             return func
331 | 
332 |         return decorator
333 | 
334 |     def call_tool(self):
335 |         def decorator(
336 |             func: Callable[
337 |                 ...,
338 |                 Awaitable[
339 |                     Sequence[
340 |                         types.TextContent | types.ImageContent | types.EmbeddedResource
341 |                     ]
342 |                 ],
343 |             ],
344 |         ):
345 |             logger.debug("Registering handler for CallToolRequest")
346 | 
347 |             async def handler(req: types.CallToolRequest):
348 |                 try:
349 |                     results = await func(req.params.name, (req.params.arguments or {}))
350 |                     return types.ServerResult(
351 |                         types.CallToolResult(content=list(results), isError=False)
352 |                     )
353 |                 except Exception as e:
354 |                     return types.ServerResult(
355 |                         types.CallToolResult(
356 |                             content=[types.TextContent(type="text", text=str(e))],
357 |                             isError=True,
358 |                         )
359 |                     )
360 | 
361 |             self.request_handlers[types.CallToolRequest] = handler
362 |             return func
363 | 
364 |         return decorator
365 | 
366 |     def progress_notification(self):
367 |         def decorator(
368 |             func: Callable[[str | int, float, float | None], Awaitable[None]],
369 |         ):
370 |             logger.debug("Registering handler for ProgressNotification")
371 | 
372 |             async def handler(req: types.ProgressNotification):
373 |                 await func(
374 |                     req.params.progressToken, req.params.progress, req.params.total
375 |                 )
376 | 
377 |             self.notification_handlers[types.ProgressNotification] = handler
378 |             return func
379 | 
380 |         return decorator
381 | 
382 |     def completion(self):
383 |         """Provides completions for prompts and resource templates"""
384 | 
385 |         def decorator(
386 |             func: Callable[
387 |                 [
388 |                     types.PromptReference | types.ResourceReference,
389 |                     types.CompletionArgument,
390 |                 ],
391 |                 Awaitable[types.Completion | None],
392 |             ],
393 |         ):
394 |             logger.debug("Registering handler for CompleteRequest")
395 | 
396 |             async def handler(req: types.CompleteRequest):
397 |                 completion = await func(req.params.ref, req.params.argument)
398 |                 return types.ServerResult(
399 |                     types.CompleteResult(
400 |                         completion=completion
401 |                         if completion is not None
402 |                         else types.Completion(values=[], total=None, hasMore=None),
403 |                     )
404 |                 )
405 | 
406 |             self.request_handlers[types.CompleteRequest] = handler
407 |             return func
408 | 
409 |         return decorator
410 | 
411 |     async def run(
412 |         self,
413 |         read_stream: MemoryObjectReceiveStream[types.JSONRPCMessage | Exception],
414 |         write_stream: MemoryObjectSendStream[types.JSONRPCMessage],
415 |         initialization_options: InitializationOptions,
416 |         # When False, exceptions are returned as messages to the client.
417 |         # When True, exceptions are raised, which will cause the server to shut down
418 |         # but also make tracing exceptions much easier during testing and when using
419 |         # in-process servers.
420 |         raise_exceptions: bool = False,
421 |     ):
422 |         with warnings.catch_warnings(record=True) as w:
423 |             async with ServerSession(
424 |                 read_stream, write_stream, initialization_options
425 |             ) as session:
426 |                 async for message in session.incoming_messages:
427 |                     logger.debug(f"Received message: {message}")
428 | 
429 |                     match message:
430 |                         case RequestResponder(request=types.ClientRequest(root=req)):
431 |                             logger.info(
432 |                                 f"Processing request of type {type(req).__name__}"
433 |                             )
434 |                             if type(req) in self.request_handlers:
435 |                                 handler = self.request_handlers[type(req)]
436 |                                 logger.debug(
437 |                                     f"Dispatching request of type {type(req).__name__}"
438 |                                 )
439 | 
440 |                                 token = None
441 |                                 try:
442 |                                     # Set our global state that can be retrieved via
443 |                                     # app.get_request_context()
444 |                                     token = request_ctx.set(
445 |                                         RequestContext(
446 |                                             message.request_id,
447 |                                             message.request_meta,
448 |                                             session,
449 |                                         )
450 |                                     )
451 |                                     response = await handler(req)
452 |                                 except McpError as err:
453 |                                     response = err.error
454 |                                 except Exception as err:
455 |                                     if raise_exceptions:
456 |                                         raise err
457 |                                     response = types.ErrorData(
458 |                                         code=0, message=str(err), data=None
459 |                                     )
460 |                                 finally:
461 |                                     # Reset the global state after we are done
462 |                                     if token is not None:
463 |                                         request_ctx.reset(token)
464 | 
465 |                                 await message.respond(response)
466 |                             else:
467 |                                 await message.respond(
468 |                                     types.ErrorData(
469 |                                         code=types.METHOD_NOT_FOUND,
470 |                                         message="Method not found",
471 |                                     )
472 |                                 )
473 | 
474 |                             logger.debug("Response sent")
475 |                         case types.ClientNotification(root=notify):
476 |                             if type(notify) in self.notification_handlers:
477 |                                 assert type(notify) in self.notification_handlers
478 | 
479 |                                 handler = self.notification_handlers[type(notify)]
480 |                                 logger.debug(
481 |                                     f"Dispatching notification of type "
482 |                                     f"{type(notify).__name__}"
483 |                                 )
484 | 
485 |                                 try:
486 |                                     await handler(notify)
487 |                                 except Exception as err:
488 |                                     logger.error(
489 |                                         f"Uncaught exception in notification handler: "
490 |                                         f"{err}"
491 |                                     )
492 | 
493 |                     for warning in w:
494 |                         logger.info(
495 |                             f"Warning: {warning.category.__name__}: {warning.message}"
496 |                         )
497 | 
498 | 
499 | async def _ping_handler(request: types.PingRequest) -> types.ServerResult:
500 |     return types.ServerResult(types.EmptyResult())
501 | 


--------------------------------------------------------------------------------
/src/mcp/server/__main__.py:
--------------------------------------------------------------------------------
 1 | import importlib.metadata
 2 | import logging
 3 | import sys
 4 | 
 5 | import anyio
 6 | 
 7 | from mcp.server.models import InitializationOptions
 8 | from mcp.server.session import ServerSession
 9 | from mcp.server.stdio import stdio_server
10 | from mcp.types import ServerCapabilities
11 | 
12 | if not sys.warnoptions:
13 |     import warnings
14 | 
15 |     warnings.simplefilter("ignore")
16 | 
17 | logging.basicConfig(level=logging.INFO)
18 | logger = logging.getLogger("server")
19 | 
20 | 
21 | async def receive_loop(session: ServerSession):
22 |     logger.info("Starting receive loop")
23 |     async for message in session.incoming_messages:
24 |         if isinstance(message, Exception):
25 |             logger.error("Error: %s", message)
26 |             continue
27 | 
28 |         logger.info("Received message from client: %s", message)
29 | 
30 | 
31 | async def main():
32 |     version = importlib.metadata.version("mcp")
33 |     async with stdio_server() as (read_stream, write_stream):
34 |         async with (
35 |             ServerSession(
36 |                 read_stream,
37 |                 write_stream,
38 |                 InitializationOptions(
39 |                     server_name="mcp",
40 |                     server_version=version,
41 |                     capabilities=ServerCapabilities(),
42 |                 ),
43 |             ) as session,
44 |             write_stream,
45 |         ):
46 |             await receive_loop(session)
47 | 
48 | 
49 | if __name__ == "__main__":
50 |     anyio.run(main, backend="trio")
51 | 


--------------------------------------------------------------------------------
/src/mcp/server/models.py:
--------------------------------------------------------------------------------
 1 | """
 2 | This module provides simpler types to use with the server for managing prompts
 3 | and tools.
 4 | """
 5 | 
 6 | from pydantic import BaseModel
 7 | 
 8 | from mcp.types import (
 9 |     ServerCapabilities,
10 | )
11 | 
12 | 
13 | class InitializationOptions(BaseModel):
14 |     server_name: str
15 |     server_version: str
16 |     capabilities: ServerCapabilities
17 | 


--------------------------------------------------------------------------------
/src/mcp/server/session.py:
--------------------------------------------------------------------------------
  1 | """
  2 | ServerSession Module
  3 | 
  4 | This module provides the ServerSession class, which manages communication between the
  5 | server and client in the MCP (Model Context Protocol) framework. It is most commonly
  6 | used in MCP servers to interact with the client.
  7 | 
  8 | Common usage pattern:
  9 | ```
 10 |     server = Server(name)
 11 | 
 12 |     @server.call_tool()
 13 |     async def handle_tool_call(ctx: RequestContext, arguments: dict[str, Any]) -> Any:
 14 |         # Check client capabilities before proceeding
 15 |         if ctx.session.check_client_capability(
 16 |             types.ClientCapabilities(experimental={"advanced_tools": dict()})
 17 |         ):
 18 |             # Perform advanced tool operations
 19 |             result = await perform_advanced_tool_operation(arguments)
 20 |         else:
 21 |             # Fall back to basic tool operations
 22 |             result = await perform_basic_tool_operation(arguments)
 23 | 
 24 |         return result
 25 | 
 26 |     @server.list_prompts()
 27 |     async def handle_list_prompts(ctx: RequestContext) -> list[types.Prompt]:
 28 |         # Access session for any necessary checks or operations
 29 |         if ctx.session.client_params:
 30 |             # Customize prompts based on client initialization parameters
 31 |             return generate_custom_prompts(ctx.session.client_params)
 32 |         else:
 33 |             return default_prompts
 34 | ```
 35 | 
 36 | The ServerSession class is typically used internally by the Server class and should not
 37 | be instantiated directly by users of the MCP framework.
 38 | """
 39 | 
 40 | from enum import Enum
 41 | from typing import Any
 42 | 
 43 | import anyio
 44 | import anyio.lowlevel
 45 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
 46 | from pydantic import AnyUrl
 47 | 
 48 | import mcp.types as types
 49 | from mcp.server.models import InitializationOptions
 50 | from mcp.shared.session import (
 51 |     BaseSession,
 52 |     RequestResponder,
 53 | )
 54 | 
 55 | 
 56 | class InitializationState(Enum):
 57 |     NotInitialized = 1
 58 |     Initializing = 2
 59 |     Initialized = 3
 60 | 
 61 | 
 62 | class ServerSession(
 63 |     BaseSession[
 64 |         types.ServerRequest,
 65 |         types.ServerNotification,
 66 |         types.ServerResult,
 67 |         types.ClientRequest,
 68 |         types.ClientNotification,
 69 |     ]
 70 | ):
 71 |     _initialized: InitializationState = InitializationState.NotInitialized
 72 |     _client_params: types.InitializeRequestParams | None = None
 73 | 
 74 |     def __init__(
 75 |         self,
 76 |         read_stream: MemoryObjectReceiveStream[types.JSONRPCMessage | Exception],
 77 |         write_stream: MemoryObjectSendStream[types.JSONRPCMessage],
 78 |         init_options: InitializationOptions,
 79 |     ) -> None:
 80 |         super().__init__(
 81 |             read_stream, write_stream, types.ClientRequest, types.ClientNotification
 82 |         )
 83 |         self._initialization_state = InitializationState.NotInitialized
 84 |         self._init_options = init_options
 85 | 
 86 |     @property
 87 |     def client_params(self) -> types.InitializeRequestParams | None:
 88 |         return self._client_params
 89 | 
 90 |     def check_client_capability(self, capability: types.ClientCapabilities) -> bool:
 91 |         """Check if the client supports a specific capability."""
 92 |         if self._client_params is None:
 93 |             return False
 94 | 
 95 |         # Get client capabilities from initialization params
 96 |         client_caps = self._client_params.capabilities
 97 | 
 98 |         # Check each specified capability in the passed in capability object
 99 |         if capability.roots is not None:
100 |             if client_caps.roots is None:
101 |                 return False
102 |             if capability.roots.listChanged and not client_caps.roots.listChanged:
103 |                 return False
104 | 
105 |         if capability.sampling is not None:
106 |             if client_caps.sampling is None:
107 |                 return False
108 | 
109 |         if capability.experimental is not None:
110 |             if client_caps.experimental is None:
111 |                 return False
112 |             # Check each experimental capability
113 |             for exp_key, exp_value in capability.experimental.items():
114 |                 if (
115 |                     exp_key not in client_caps.experimental
116 |                     or client_caps.experimental[exp_key] != exp_value
117 |                 ):
118 |                     return False
119 | 
120 |         return True
121 | 
122 |     async def _received_request(
123 |         self, responder: RequestResponder[types.ClientRequest, types.ServerResult]
124 |     ):
125 |         match responder.request.root:
126 |             case types.InitializeRequest(params=params):
127 |                 self._initialization_state = InitializationState.Initializing
128 |                 self._client_params = params
129 |                 await responder.respond(
130 |                     types.ServerResult(
131 |                         types.InitializeResult(
132 |                             protocolVersion=types.LATEST_PROTOCOL_VERSION,
133 |                             capabilities=self._init_options.capabilities,
134 |                             serverInfo=types.Implementation(
135 |                                 name=self._init_options.server_name,
136 |                                 version=self._init_options.server_version,
137 |                             ),
138 |                         )
139 |                     )
140 |                 )
141 |             case _:
142 |                 if self._initialization_state != InitializationState.Initialized:
143 |                     raise RuntimeError(
144 |                         "Received request before initialization was complete"
145 |                     )
146 | 
147 |     async def _received_notification(
148 |         self, notification: types.ClientNotification
149 |     ) -> None:
150 |         # Need this to avoid ASYNC910
151 |         await anyio.lowlevel.checkpoint()
152 |         match notification.root:
153 |             case types.InitializedNotification():
154 |                 self._initialization_state = InitializationState.Initialized
155 |             case _:
156 |                 if self._initialization_state != InitializationState.Initialized:
157 |                     raise RuntimeError(
158 |                         "Received notification before initialization was complete"
159 |                     )
160 | 
161 |     async def send_log_message(
162 |         self, level: types.LoggingLevel, data: Any, logger: str | None = None
163 |     ) -> None:
164 |         """Send a log message notification."""
165 |         await self.send_notification(
166 |             types.ServerNotification(
167 |                 types.LoggingMessageNotification(
168 |                     method="notifications/message",
169 |                     params=types.LoggingMessageNotificationParams(
170 |                         level=level,
171 |                         data=data,
172 |                         logger=logger,
173 |                     ),
174 |                 )
175 |             )
176 |         )
177 | 
178 |     async def send_resource_updated(self, uri: AnyUrl) -> None:
179 |         """Send a resource updated notification."""
180 |         await self.send_notification(
181 |             types.ServerNotification(
182 |                 types.ResourceUpdatedNotification(
183 |                     method="notifications/resources/updated",
184 |                     params=types.ResourceUpdatedNotificationParams(uri=uri),
185 |                 )
186 |             )
187 |         )
188 | 
189 |     async def create_message(
190 |         self,
191 |         messages: list[types.SamplingMessage],
192 |         *,
193 |         max_tokens: int,
194 |         system_prompt: str | None = None,
195 |         include_context: types.IncludeContext | None = None,
196 |         temperature: float | None = None,
197 |         stop_sequences: list[str] | None = None,
198 |         metadata: dict[str, Any] | None = None,
199 |         model_preferences: types.ModelPreferences | None = None,
200 |     ) -> types.CreateMessageResult:
201 |         """Send a sampling/create_message request."""
202 |         return await self.send_request(
203 |             types.ServerRequest(
204 |                 types.CreateMessageRequest(
205 |                     method="sampling/createMessage",
206 |                     params=types.CreateMessageRequestParams(
207 |                         messages=messages,
208 |                         systemPrompt=system_prompt,
209 |                         includeContext=include_context,
210 |                         temperature=temperature,
211 |                         maxTokens=max_tokens,
212 |                         stopSequences=stop_sequences,
213 |                         metadata=metadata,
214 |                         modelPreferences=model_preferences,
215 |                     ),
216 |                 )
217 |             ),
218 |             types.CreateMessageResult,
219 |         )
220 | 
221 |     async def list_roots(self) -> types.ListRootsResult:
222 |         """Send a roots/list request."""
223 |         return await self.send_request(
224 |             types.ServerRequest(
225 |                 types.ListRootsRequest(
226 |                     method="roots/list",
227 |                 )
228 |             ),
229 |             types.ListRootsResult,
230 |         )
231 | 
232 |     async def send_ping(self) -> types.EmptyResult:
233 |         """Send a ping request."""
234 |         return await self.send_request(
235 |             types.ServerRequest(
236 |                 types.PingRequest(
237 |                     method="ping",
238 |                 )
239 |             ),
240 |             types.EmptyResult,
241 |         )
242 | 
243 |     async def send_progress_notification(
244 |         self, progress_token: str | int, progress: float, total: float | None = None
245 |     ) -> None:
246 |         """Send a progress notification."""
247 |         await self.send_notification(
248 |             types.ServerNotification(
249 |                 types.ProgressNotification(
250 |                     method="notifications/progress",
251 |                     params=types.ProgressNotificationParams(
252 |                         progressToken=progress_token,
253 |                         progress=progress,
254 |                         total=total,
255 |                     ),
256 |                 )
257 |             )
258 |         )
259 | 
260 |     async def send_resource_list_changed(self) -> None:
261 |         """Send a resource list changed notification."""
262 |         await self.send_notification(
263 |             types.ServerNotification(
264 |                 types.ResourceListChangedNotification(
265 |                     method="notifications/resources/list_changed",
266 |                 )
267 |             )
268 |         )
269 | 
270 |     async def send_tool_list_changed(self) -> None:
271 |         """Send a tool list changed notification."""
272 |         await self.send_notification(
273 |             types.ServerNotification(
274 |                 types.ToolListChangedNotification(
275 |                     method="notifications/tools/list_changed",
276 |                 )
277 |             )
278 |         )
279 | 
280 |     async def send_prompt_list_changed(self) -> None:
281 |         """Send a prompt list changed notification."""
282 |         await self.send_notification(
283 |             types.ServerNotification(
284 |                 types.PromptListChangedNotification(
285 |                     method="notifications/prompts/list_changed",
286 |                 )
287 |             )
288 |         )
289 | 


--------------------------------------------------------------------------------
/src/mcp/server/sse.py:
--------------------------------------------------------------------------------
  1 | """
  2 | SSE Server Transport Module
  3 | 
  4 | This module implements a Server-Sent Events (SSE) transport layer for MCP servers.
  5 | 
  6 | Example usage:
  7 | ```
  8 |     # Create an SSE transport at an endpoint
  9 |     sse = SseServerTransport("/messages")
 10 | 
 11 |     # Create Starlette routes for SSE and message handling
 12 |     routes = [
 13 |         Route("/sse", endpoint=handle_sse),
 14 |         Route("/messages", endpoint=handle_messages, methods=["POST"])
 15 |     ]
 16 | 
 17 |     # Define handler functions
 18 |     async def handle_sse(request):
 19 |         async with sse.connect_sse(
 20 |             request.scope, request.receive, request._send
 21 |         ) as streams:
 22 |             await app.run(
 23 |                 streams[0], streams[1], app.create_initialization_options()
 24 |             )
 25 | 
 26 |     async def handle_messages(request):
 27 |         await sse.handle_post_message(request.scope, request.receive, request._send)
 28 | 
 29 |     # Create and run Starlette app
 30 |     starlette_app = Starlette(routes=routes)
 31 |     uvicorn.run(starlette_app, host="0.0.0.0", port=port)
 32 | ```
 33 | 
 34 | See SseServerTransport class documentation for more details.
 35 | """
 36 | 
 37 | import logging
 38 | from contextlib import asynccontextmanager
 39 | from typing import Any
 40 | from urllib.parse import quote
 41 | from uuid import UUID, uuid4
 42 | 
 43 | import anyio
 44 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
 45 | from pydantic import ValidationError
 46 | from sse_starlette import EventSourceResponse
 47 | from starlette.requests import Request
 48 | from starlette.responses import Response
 49 | from starlette.types import Receive, Scope, Send
 50 | 
 51 | import mcp.types as types
 52 | 
 53 | logger = logging.getLogger(__name__)
 54 | 
 55 | 
 56 | class SseServerTransport:
 57 |     """
 58 |     SSE server transport for MCP. This class provides _two_ ASGI applications,
 59 |     suitable to be used with a framework like Starlette and a server like Hypercorn:
 60 | 
 61 |         1. connect_sse() is an ASGI application which receives incoming GET requests,
 62 |            and sets up a new SSE stream to send server messages to the client.
 63 |         2. handle_post_message() is an ASGI application which receives incoming POST
 64 |            requests, which should contain client messages that link to a
 65 |            previously-established SSE session.
 66 |     """
 67 | 
 68 |     _endpoint: str
 69 |     _read_stream_writers: dict[
 70 |         UUID, MemoryObjectSendStream[types.JSONRPCMessage | Exception]
 71 |     ]
 72 | 
 73 |     def __init__(self, endpoint: str) -> None:
 74 |         """
 75 |         Creates a new SSE server transport, which will direct the client to POST
 76 |         messages to the relative or absolute URL given.
 77 |         """
 78 | 
 79 |         super().__init__()
 80 |         self._endpoint = endpoint
 81 |         self._read_stream_writers = {}
 82 |         logger.debug(f"SseServerTransport initialized with endpoint: {endpoint}")
 83 | 
 84 |     @asynccontextmanager
 85 |     async def connect_sse(self, scope: Scope, receive: Receive, send: Send):
 86 |         if scope["type"] != "http":
 87 |             logger.error("connect_sse received non-HTTP request")
 88 |             raise ValueError("connect_sse can only handle HTTP requests")
 89 | 
 90 |         logger.debug("Setting up SSE connection")
 91 |         read_stream: MemoryObjectReceiveStream[types.JSONRPCMessage | Exception]
 92 |         read_stream_writer: MemoryObjectSendStream[types.JSONRPCMessage | Exception]
 93 | 
 94 |         write_stream: MemoryObjectSendStream[types.JSONRPCMessage]
 95 |         write_stream_reader: MemoryObjectReceiveStream[types.JSONRPCMessage]
 96 | 
 97 |         read_stream_writer, read_stream = anyio.create_memory_object_stream(0)
 98 |         write_stream, write_stream_reader = anyio.create_memory_object_stream(0)
 99 | 
100 |         session_id = uuid4()
101 |         session_uri = f"{quote(self._endpoint)}?session_id={session_id.hex}"
102 |         self._read_stream_writers[session_id] = read_stream_writer
103 |         logger.debug(f"Created new session with ID: {session_id}")
104 | 
105 |         sse_stream_writer, sse_stream_reader = anyio.create_memory_object_stream(
106 |             0, dict[str, Any]
107 |         )
108 | 
109 |         async def sse_writer():
110 |             logger.debug("Starting SSE writer")
111 |             async with sse_stream_writer, write_stream_reader:
112 |                 await sse_stream_writer.send({"event": "endpoint", "data": session_uri})
113 |                 logger.debug(f"Sent endpoint event: {session_uri}")
114 | 
115 |                 async for message in write_stream_reader:
116 |                     logger.debug(f"Sending message via SSE: {message}")
117 |                     await sse_stream_writer.send(
118 |                         {
119 |                             "event": "message",
120 |                             "data": message.model_dump_json(
121 |                                 by_alias=True, exclude_none=True
122 |                             ),
123 |                         }
124 |                     )
125 | 
126 |         async with anyio.create_task_group() as tg:
127 |             response = EventSourceResponse(
128 |                 content=sse_stream_reader, data_sender_callable=sse_writer
129 |             )
130 |             logger.debug("Starting SSE response task")
131 |             tg.start_soon(response, scope, receive, send)
132 | 
133 |             logger.debug("Yielding read and write streams")
134 |             yield (read_stream, write_stream)
135 | 
136 |     async def handle_post_message(
137 |         self, scope: Scope, receive: Receive, send: Send
138 |     ) -> None:
139 |         logger.debug("Handling POST message")
140 |         request = Request(scope, receive)
141 | 
142 |         session_id_param = request.query_params.get("session_id")
143 |         if session_id_param is None:
144 |             logger.warning("Received request without session_id")
145 |             response = Response("session_id is required", status_code=400)
146 |             return await response(scope, receive, send)
147 | 
148 |         try:
149 |             session_id = UUID(hex=session_id_param)
150 |             logger.debug(f"Parsed session ID: {session_id}")
151 |         except ValueError:
152 |             logger.warning(f"Received invalid session ID: {session_id_param}")
153 |             response = Response("Invalid session ID", status_code=400)
154 |             return await response(scope, receive, send)
155 | 
156 |         writer = self._read_stream_writers.get(session_id)
157 |         if not writer:
158 |             logger.warning(f"Could not find session for ID: {session_id}")
159 |             response = Response("Could not find session", status_code=404)
160 |             return await response(scope, receive, send)
161 | 
162 |         json = await request.json()
163 |         logger.debug(f"Received JSON: {json}")
164 | 
165 |         try:
166 |             message = types.JSONRPCMessage.model_validate(json)
167 |             logger.debug(f"Validated client message: {message}")
168 |         except ValidationError as err:
169 |             logger.error(f"Failed to parse message: {err}")
170 |             response = Response("Could not parse message", status_code=400)
171 |             await response(scope, receive, send)
172 |             await writer.send(err)
173 |             return
174 | 
175 |         logger.debug(f"Sending message to writer: {message}")
176 |         response = Response("Accepted", status_code=202)
177 |         await response(scope, receive, send)
178 |         await writer.send(message)
179 | 


--------------------------------------------------------------------------------
/src/mcp/server/stdio.py:
--------------------------------------------------------------------------------
 1 | """
 2 | Stdio Server Transport Module
 3 | 
 4 | This module provides functionality for creating an stdio-based transport layer
 5 | that can be used to communicate with an MCP client through standard input/output
 6 | streams.
 7 | 
 8 | Example usage:
 9 | ```
10 |     async def run_server():
11 |         async with stdio_server() as (read_stream, write_stream):
12 |             # read_stream contains incoming JSONRPCMessages from stdin
13 |             # write_stream allows sending JSONRPCMessages to stdout
14 |             server = await create_my_server()
15 |             await server.run(read_stream, write_stream, init_options)
16 | 
17 |     anyio.run(run_server)
18 | ```
19 | """
20 | 
21 | import sys
22 | from contextlib import asynccontextmanager
23 | 
24 | import anyio
25 | import anyio.lowlevel
26 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
27 | 
28 | import mcp.types as types
29 | 
30 | 
31 | @asynccontextmanager
32 | async def stdio_server(
33 |     stdin: anyio.AsyncFile[str] | None = None,
34 |     stdout: anyio.AsyncFile[str] | None = None,
35 | ):
36 |     """
37 |     Server transport for stdio: this communicates with an MCP client by reading
38 |     from the current process' stdin and writing to stdout.
39 |     """
40 |     # Purposely not using context managers for these, as we don't want to close
41 |     # standard process handles.
42 |     if not stdin:
43 |         stdin = anyio.wrap_file(sys.stdin)
44 |     if not stdout:
45 |         stdout = anyio.wrap_file(sys.stdout)
46 | 
47 |     read_stream: MemoryObjectReceiveStream[types.JSONRPCMessage | Exception]
48 |     read_stream_writer: MemoryObjectSendStream[types.JSONRPCMessage | Exception]
49 | 
50 |     write_stream: MemoryObjectSendStream[types.JSONRPCMessage]
51 |     write_stream_reader: MemoryObjectReceiveStream[types.JSONRPCMessage]
52 | 
53 |     read_stream_writer, read_stream = anyio.create_memory_object_stream(0)
54 |     write_stream, write_stream_reader = anyio.create_memory_object_stream(0)
55 | 
56 |     async def stdin_reader():
57 |         try:
58 |             async with read_stream_writer:
59 |                 async for line in stdin:
60 |                     try:
61 |                         message = types.JSONRPCMessage.model_validate_json(line)
62 |                     except Exception as exc:
63 |                         await read_stream_writer.send(exc)
64 |                         continue
65 | 
66 |                     await read_stream_writer.send(message)
67 |         except anyio.ClosedResourceError:
68 |             await anyio.lowlevel.checkpoint()
69 | 
70 |     async def stdout_writer():
71 |         try:
72 |             async with write_stream_reader:
73 |                 async for message in write_stream_reader:
74 |                     json = message.model_dump_json(by_alias=True, exclude_none=True)
75 |                     await stdout.write(json + "\n")
76 |                     await stdout.flush()
77 |         except anyio.ClosedResourceError:
78 |             await anyio.lowlevel.checkpoint()
79 | 
80 |     async with anyio.create_task_group() as tg:
81 |         tg.start_soon(stdin_reader)
82 |         tg.start_soon(stdout_writer)
83 |         yield read_stream, write_stream
84 | 


--------------------------------------------------------------------------------
/src/mcp/server/websocket.py:
--------------------------------------------------------------------------------
 1 | import logging
 2 | from contextlib import asynccontextmanager
 3 | 
 4 | import anyio
 5 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
 6 | from starlette.types import Receive, Scope, Send
 7 | from starlette.websockets import WebSocket
 8 | 
 9 | import mcp.types as types
10 | 
11 | logger = logging.getLogger(__name__)
12 | 
13 | 
14 | @asynccontextmanager
15 | async def websocket_server(scope: Scope, receive: Receive, send: Send):
16 |     """
17 |     WebSocket server transport for MCP. This is an ASGI application, suitable to be
18 |     used with a framework like Starlette and a server like Hypercorn.
19 |     """
20 | 
21 |     websocket = WebSocket(scope, receive, send)
22 |     await websocket.accept(subprotocol="mcp")
23 | 
24 |     read_stream: MemoryObjectReceiveStream[types.JSONRPCMessage | Exception]
25 |     read_stream_writer: MemoryObjectSendStream[types.JSONRPCMessage | Exception]
26 | 
27 |     write_stream: MemoryObjectSendStream[types.JSONRPCMessage]
28 |     write_stream_reader: MemoryObjectReceiveStream[types.JSONRPCMessage]
29 | 
30 |     read_stream_writer, read_stream = anyio.create_memory_object_stream(0)
31 |     write_stream, write_stream_reader = anyio.create_memory_object_stream(0)
32 | 
33 |     async def ws_reader():
34 |         try:
35 |             async with read_stream_writer:
36 |                 async for message in websocket.iter_json():
37 |                     try:
38 |                         client_message = types.JSONRPCMessage.model_validate(message)
39 |                     except Exception as exc:
40 |                         await read_stream_writer.send(exc)
41 |                         continue
42 | 
43 |                     await read_stream_writer.send(client_message)
44 |         except anyio.ClosedResourceError:
45 |             await websocket.close()
46 | 
47 |     async def ws_writer():
48 |         try:
49 |             async with write_stream_reader:
50 |                 async for message in write_stream_reader:
51 |                     obj = message.model_dump(
52 |                         by_alias=True, mode="json", exclude_none=True
53 |                     )
54 |                     await websocket.send_json(obj)
55 |         except anyio.ClosedResourceError:
56 |             await websocket.close()
57 | 
58 |     async with anyio.create_task_group() as tg:
59 |         tg.start_soon(ws_reader)
60 |         tg.start_soon(ws_writer)
61 |         yield (read_stream, write_stream)
62 | 


--------------------------------------------------------------------------------
/src/mcp/shared/__init__.py:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/aaf32b530738ff79ba607c2884374243350f521c/src/mcp/shared/__init__.py


--------------------------------------------------------------------------------
/src/mcp/shared/context.py:
--------------------------------------------------------------------------------
 1 | from dataclasses import dataclass
 2 | from typing import Generic, TypeVar
 3 | 
 4 | from mcp.shared.session import BaseSession
 5 | from mcp.types import RequestId, RequestParams
 6 | 
 7 | SessionT = TypeVar("SessionT", bound=BaseSession)
 8 | 
 9 | 
10 | @dataclass
11 | class RequestContext(Generic[SessionT]):
12 |     request_id: RequestId
13 |     meta: RequestParams.Meta | None
14 |     session: SessionT
15 | 


--------------------------------------------------------------------------------
/src/mcp/shared/exceptions.py:
--------------------------------------------------------------------------------
 1 | from mcp.types import ErrorData
 2 | 
 3 | 
 4 | class McpError(Exception):
 5 |     """
 6 |     Exception type raised when an error arrives over an MCP connection.
 7 |     """
 8 | 
 9 |     error: ErrorData
10 | 


--------------------------------------------------------------------------------
/src/mcp/shared/memory.py:
--------------------------------------------------------------------------------
 1 | """
 2 | In-memory transports
 3 | """
 4 | 
 5 | from contextlib import asynccontextmanager
 6 | from datetime import timedelta
 7 | from typing import AsyncGenerator
 8 | 
 9 | import anyio
10 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
11 | 
12 | from mcp.client.session import ClientSession
13 | from mcp.server import Server
14 | from mcp.types import JSONRPCMessage
15 | 
16 | MessageStream = tuple[
17 |     MemoryObjectReceiveStream[JSONRPCMessage | Exception],
18 |     MemoryObjectSendStream[JSONRPCMessage],
19 | ]
20 | 
21 | 
22 | @asynccontextmanager
23 | async def create_client_server_memory_streams() -> (
24 |     AsyncGenerator[tuple[MessageStream, MessageStream], None]
25 | ):
26 |     """
27 |     Creates a pair of bidirectional memory streams for client-server communication.
28 | 
29 |     Returns:
30 |         A tuple of (client_streams, server_streams) where each is a tuple of
31 |         (read_stream, write_stream)
32 |     """
33 |     # Create streams for both directions
34 |     server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream[
35 |         JSONRPCMessage | Exception
36 |     ](1)
37 |     client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream[
38 |         JSONRPCMessage | Exception
39 |     ](1)
40 | 
41 |     client_streams = (server_to_client_receive, client_to_server_send)
42 |     server_streams = (client_to_server_receive, server_to_client_send)
43 | 
44 |     async with (
45 |         server_to_client_receive,
46 |         client_to_server_send,
47 |         client_to_server_receive,
48 |         server_to_client_send,
49 |     ):
50 |         yield client_streams, server_streams
51 | 
52 | 
53 | @asynccontextmanager
54 | async def create_connected_server_and_client_session(
55 |     server: Server,
56 |     read_timeout_seconds: timedelta | None = None,
57 |     raise_exceptions: bool = False,
58 | ) -> AsyncGenerator[ClientSession, None]:
59 |     """Creates a ClientSession that is connected to a running MCP server."""
60 |     async with create_client_server_memory_streams() as (
61 |         client_streams,
62 |         server_streams,
63 |     ):
64 |         client_read, client_write = client_streams
65 |         server_read, server_write = server_streams
66 | 
67 |         # Create a cancel scope for the server task
68 |         async with anyio.create_task_group() as tg:
69 |             tg.start_soon(
70 |                 lambda: server.run(
71 |                     server_read,
72 |                     server_write,
73 |                     server.create_initialization_options(),
74 |                     raise_exceptions=raise_exceptions,
75 |                 )
76 |             )
77 | 
78 |             try:
79 |                 async with ClientSession(
80 |                     read_stream=client_read,
81 |                     write_stream=client_write,
82 |                     read_timeout_seconds=read_timeout_seconds,
83 |                 ) as client_session:
84 |                     await client_session.initialize()
85 |                     yield client_session
86 |             finally:
87 |                 tg.cancel_scope.cancel()
88 | 


--------------------------------------------------------------------------------
/src/mcp/shared/progress.py:
--------------------------------------------------------------------------------
 1 | from contextlib import contextmanager
 2 | from dataclasses import dataclass, field
 3 | 
 4 | from pydantic import BaseModel
 5 | 
 6 | from mcp.shared.context import RequestContext
 7 | from mcp.shared.session import BaseSession
 8 | from mcp.types import ProgressToken
 9 | 
10 | 
11 | class Progress(BaseModel):
12 |     progress: float
13 |     total: float | None
14 | 
15 | 
16 | @dataclass
17 | class ProgressContext:
18 |     session: BaseSession
19 |     progress_token: ProgressToken
20 |     total: float | None
21 |     current: float = field(default=0.0, init=False)
22 | 
23 |     async def progress(self, amount: float) -> None:
24 |         self.current += amount
25 | 
26 |         await self.session.send_progress_notification(
27 |             self.progress_token, self.current, total=self.total
28 |         )
29 | 
30 | 
31 | @contextmanager
32 | def progress(ctx: RequestContext, total: float | None = None):
33 |     if ctx.meta is None or ctx.meta.progressToken is None:
34 |         raise ValueError("No progress token provided")
35 | 
36 |     progress_ctx = ProgressContext(ctx.session, ctx.meta.progressToken, total)
37 |     try:
38 |         yield progress_ctx
39 |     finally:
40 |         pass
41 | 


--------------------------------------------------------------------------------
/src/mcp/shared/session.py:
--------------------------------------------------------------------------------
  1 | from contextlib import AbstractAsyncContextManager
  2 | from datetime import timedelta
  3 | from typing import Generic, TypeVar
  4 | 
  5 | import anyio
  6 | import anyio.lowlevel
  7 | import httpx
  8 | from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
  9 | from pydantic import BaseModel
 10 | 
 11 | from mcp.shared.exceptions import McpError
 12 | from mcp.types import (
 13 |     ClientNotification,
 14 |     ClientRequest,
 15 |     ClientResult,
 16 |     ErrorData,
 17 |     JSONRPCError,
 18 |     JSONRPCMessage,
 19 |     JSONRPCNotification,
 20 |     JSONRPCRequest,
 21 |     JSONRPCResponse,
 22 |     RequestParams,
 23 |     ServerNotification,
 24 |     ServerRequest,
 25 |     ServerResult,
 26 | )
 27 | 
 28 | SendRequestT = TypeVar("SendRequestT", ClientRequest, ServerRequest)
 29 | SendResultT = TypeVar("SendResultT", ClientResult, ServerResult)
 30 | SendNotificationT = TypeVar("SendNotificationT", ClientNotification, ServerNotification)
 31 | ReceiveRequestT = TypeVar("ReceiveRequestT", ClientRequest, ServerRequest)
 32 | ReceiveResultT = TypeVar("ReceiveResultT", bound=BaseModel)
 33 | ReceiveNotificationT = TypeVar(
 34 |     "ReceiveNotificationT", ClientNotification, ServerNotification
 35 | )
 36 | 
 37 | RequestId = str | int
 38 | 
 39 | 
 40 | class RequestResponder(Generic[ReceiveRequestT, SendResultT]):
 41 |     def __init__(
 42 |         self,
 43 |         request_id: RequestId,
 44 |         request_meta: RequestParams.Meta | None,
 45 |         request: ReceiveRequestT,
 46 |         session: "BaseSession",
 47 |     ) -> None:
 48 |         self.request_id = request_id
 49 |         self.request_meta = request_meta
 50 |         self.request = request
 51 |         self._session = session
 52 |         self._responded = False
 53 | 
 54 |     async def respond(self, response: SendResultT | ErrorData) -> None:
 55 |         assert not self._responded, "Request already responded to"
 56 |         self._responded = True
 57 | 
 58 |         await self._session._send_response(
 59 |             request_id=self.request_id, response=response
 60 |         )
 61 | 
 62 | 
 63 | class BaseSession(
 64 |     AbstractAsyncContextManager,
 65 |     Generic[
 66 |         SendRequestT,
 67 |         SendNotificationT,
 68 |         SendResultT,
 69 |         ReceiveRequestT,
 70 |         ReceiveNotificationT,
 71 |     ],
 72 | ):
 73 |     """
 74 |     Implements an MCP "session" on top of read/write streams, including features
 75 |     like request/response linking, notifications, and progress.
 76 | 
 77 |     This class is an async context manager that automatically starts processing
 78 |     messages when entered.
 79 |     """
 80 | 
 81 |     _response_streams: dict[
 82 |         RequestId, MemoryObjectSendStream[JSONRPCResponse | JSONRPCError]
 83 |     ]
 84 |     _request_id: int
 85 | 
 86 |     def __init__(
 87 |         self,
 88 |         read_stream: MemoryObjectReceiveStream[JSONRPCMessage | Exception],
 89 |         write_stream: MemoryObjectSendStream[JSONRPCMessage],
 90 |         receive_request_type: type[ReceiveRequestT],
 91 |         receive_notification_type: type[ReceiveNotificationT],
 92 |         # If none, reading will never time out
 93 |         read_timeout_seconds: timedelta | None = None,
 94 |     ) -> None:
 95 |         self._read_stream = read_stream
 96 |         self._write_stream = write_stream
 97 |         self._response_streams = {}
 98 |         self._request_id = 0
 99 |         self._receive_request_type = receive_request_type
100 |         self._receive_notification_type = receive_notification_type
101 |         self._read_timeout_seconds = read_timeout_seconds
102 | 
103 |         self._incoming_message_stream_writer, self._incoming_message_stream_reader = (
104 |             anyio.create_memory_object_stream[
105 |                 RequestResponder[ReceiveRequestT, SendResultT]
106 |                 | ReceiveNotificationT
107 |                 | Exception
108 |             ]()
109 |         )
110 | 
111 |     async def __aenter__(self):
112 |         self._task_group = anyio.create_task_group()
113 |         await self._task_group.__aenter__()
114 |         self._task_group.start_soon(self._receive_loop)
115 |         return self
116 | 
117 |     async def __aexit__(self, exc_type, exc_val, exc_tb):
118 |         # Using BaseSession as a context manager should not block on exit (this
119 |         # would be very surprising behavior), so make sure to cancel the tasks
120 |         # in the task group.
121 |         self._task_group.cancel_scope.cancel()
122 |         return await self._task_group.__aexit__(exc_type, exc_val, exc_tb)
123 | 
124 |     async def send_request(
125 |         self,
126 |         request: SendRequestT,
127 |         result_type: type[ReceiveResultT],
128 |     ) -> ReceiveResultT:
129 |         """
130 |         Sends a request and wait for a response. Raises an McpError if the
131 |         response contains an error.
132 | 
133 |         Do not use this method to emit notifications! Use send_notification()
134 |         instead.
135 |         """
136 | 
137 |         request_id = self._request_id
138 |         self._request_id = request_id + 1
139 | 
140 |         response_stream, response_stream_reader = anyio.create_memory_object_stream[
141 |             JSONRPCResponse | JSONRPCError
142 |         ](1)
143 |         self._response_streams[request_id] = response_stream
144 | 
145 |         jsonrpc_request = JSONRPCRequest(
146 |             jsonrpc="2.0",
147 |             id=request_id,
148 |             **request.model_dump(by_alias=True, mode="json", exclude_none=True),
149 |         )
150 | 
151 |         # TODO: Support progress callbacks
152 | 
153 |         await self._write_stream.send(JSONRPCMessage(jsonrpc_request))
154 | 
155 |         try:
156 |             with anyio.fail_after(
157 |                 None
158 |                 if self._read_timeout_seconds is None
159 |                 else self._read_timeout_seconds.total_seconds()
160 |             ):
161 |                 response_or_error = await response_stream_reader.receive()
162 |         except TimeoutError:
163 |             raise McpError(
164 |                 ErrorData(
165 |                     code=httpx.codes.REQUEST_TIMEOUT,
166 |                     message=(
167 |                         f"Timed out while waiting for response to "
168 |                         f"{request.__class__.__name__}. Waited "
169 |                         f"{self._read_timeout_seconds} seconds."
170 |                     ),
171 |                 )
172 |             )
173 | 
174 |         if isinstance(response_or_error, JSONRPCError):
175 |             raise McpError(response_or_error.error)
176 |         else:
177 |             return result_type.model_validate(response_or_error.result)
178 | 
179 |     async def send_notification(self, notification: SendNotificationT) -> None:
180 |         """
181 |         Emits a notification, which is a one-way message that does not expect
182 |         a response.
183 |         """
184 |         jsonrpc_notification = JSONRPCNotification(
185 |             jsonrpc="2.0",
186 |             **notification.model_dump(by_alias=True, mode="json", exclude_none=True),
187 |         )
188 | 
189 |         await self._write_stream.send(JSONRPCMessage(jsonrpc_notification))
190 | 
191 |     async def _send_response(
192 |         self, request_id: RequestId, response: SendResultT | ErrorData
193 |     ) -> None:
194 |         if isinstance(response, ErrorData):
195 |             jsonrpc_error = JSONRPCError(jsonrpc="2.0", id=request_id, error=response)
196 |             await self._write_stream.send(JSONRPCMessage(jsonrpc_error))
197 |         else:
198 |             jsonrpc_response = JSONRPCResponse(
199 |                 jsonrpc="2.0",
200 |                 id=request_id,
201 |                 result=response.model_dump(
202 |                     by_alias=True, mode="json", exclude_none=True
203 |                 ),
204 |             )
205 |             await self._write_stream.send(JSONRPCMessage(jsonrpc_response))
206 | 
207 |     async def _receive_loop(self) -> None:
208 |         async with (
209 |             self._read_stream,
210 |             self._write_stream,
211 |             self._incoming_message_stream_writer,
212 |         ):
213 |             async for message in self._read_stream:
214 |                 if isinstance(message, Exception):
215 |                     await self._incoming_message_stream_writer.send(message)
216 |                 elif isinstance(message.root, JSONRPCRequest):
217 |                     validated_request = self._receive_request_type.model_validate(
218 |                         message.root.model_dump(
219 |                             by_alias=True, mode="json", exclude_none=True
220 |                         )
221 |                     )
222 |                     responder = RequestResponder(
223 |                         request_id=message.root.id,
224 |                         request_meta=validated_request.root.params._meta
225 |                         if validated_request.root.params
226 |                         else None,
227 |                         request=validated_request,
228 |                         session=self,
229 |                     )
230 | 
231 |                     await self._received_request(responder)
232 |                     if not responder._responded:
233 |                         await self._incoming_message_stream_writer.send(responder)
234 |                 elif isinstance(message.root, JSONRPCNotification):
235 |                     notification = self._receive_notification_type.model_validate(
236 |                         message.root.model_dump(
237 |                             by_alias=True, mode="json", exclude_none=True
238 |                         )
239 |                     )
240 | 
241 |                     await self._received_notification(notification)
242 |                     await self._incoming_message_stream_writer.send(notification)
243 |                 else:  # Response or error
244 |                     stream = self._response_streams.pop(message.root.id, None)
245 |                     if stream:
246 |                         await stream.send(message.root)
247 |                     else:
248 |                         await self._incoming_message_stream_writer.send(
249 |                             RuntimeError(
250 |                                 "Received response with an unknown "
251 |                                 f"request ID: {message}"
252 |                             )
253 |                         )
254 | 
255 |     async def _received_request(
256 |         self, responder: RequestResponder[ReceiveRequestT, SendResultT]
257 |     ) -> None:
258 |         """
259 |         Can be overridden by subclasses to handle a request without needing to
260 |         listen on the message stream.
261 | 
262 |         If the request is responded to within this method, it will not be
263 |         forwarded on to the message stream.
264 |         """
265 | 
266 |     async def _received_notification(self, notification: ReceiveNotificationT) -> None:
267 |         """
268 |         Can be overridden by subclasses to handle a notification without needing
269 |         to listen on the message stream.
270 |         """
271 | 
272 |     async def send_progress_notification(
273 |         self, progress_token: str | int, progress: float, total: float | None = None
274 |     ) -> None:
275 |         """
276 |         Sends a progress notification for a request that is currently being
277 |         processed.
278 |         """
279 | 
280 |     @property
281 |     def incoming_messages(
282 |         self,
283 |     ) -> MemoryObjectReceiveStream[
284 |         RequestResponder[ReceiveRequestT, SendResultT]
285 |         | ReceiveNotificationT
286 |         | Exception
287 |     ]:
288 |         return self._incoming_message_stream_reader
289 | 


--------------------------------------------------------------------------------
/src/mcp/shared/version.py:
--------------------------------------------------------------------------------
1 | from mcp.types import LATEST_PROTOCOL_VERSION
2 | 
3 | SUPPORTED_PROTOCOL_VERSIONS = [1, LATEST_PROTOCOL_VERSION]
4 | 


--------------------------------------------------------------------------------
/src/mcp/types.py:
--------------------------------------------------------------------------------
   1 | from typing import Any, Generic, Literal, TypeVar
   2 | 
   3 | from pydantic import BaseModel, ConfigDict, FileUrl, RootModel
   4 | from pydantic.networks import AnyUrl
   5 | 
   6 | """
   7 | Model Context Protocol bindings for Python
   8 | 
   9 | These bindings were generated from https://github.com/modelcontextprotocol/specification,
  10 | using Claude, with a prompt something like the following:
  11 | 
  12 | Generate idiomatic Python bindings for this schema for MCP, or the "Model Context
  13 | Protocol." The schema is defined in TypeScript, but there's also a JSON Schema version
  14 | for reference.
  15 | 
  16 | * For the bindings, let's use Pydantic V2 models.
  17 | * Each model should allow extra fields everywhere, by specifying `model_config =
  18 |   ConfigDict(extra='allow')`. Do this in every case, instead of a custom base class.
  19 | * Union types should be represented with a Pydantic `RootModel`.
  20 | * Define additional model classes instead of using dictionaries. Do this even if they're
  21 |   not separate types in the schema.
  22 | """
  23 | 
  24 | LATEST_PROTOCOL_VERSION = "2024-11-05"
  25 | 
  26 | ProgressToken = str | int
  27 | Cursor = str
  28 | 
  29 | 
  30 | class RequestParams(BaseModel):
  31 |     class Meta(BaseModel):
  32 |         progressToken: ProgressToken | None = None
  33 |         """
  34 |         If specified, the caller is requesting out-of-band progress notifications for
  35 |         this request (as represented by notifications/progress). The value of this
  36 |         parameter is an opaque token that will be attached to any subsequent
  37 |         notifications. The receiver is not obligated to provide these notifications.
  38 |         """
  39 | 
  40 |         model_config = ConfigDict(extra="allow")
  41 | 
  42 |     _meta: Meta | None = None
  43 | 
  44 | 
  45 | class NotificationParams(BaseModel):
  46 |     class Meta(BaseModel):
  47 |         model_config = ConfigDict(extra="allow")
  48 | 
  49 |     _meta: Meta | None = None
  50 |     """
  51 |     This parameter name is reserved by MCP to allow clients and servers to attach
  52 |     additional metadata to their notifications.
  53 |     """
  54 | 
  55 | 
  56 | RequestParamsT = TypeVar("RequestParamsT", bound=RequestParams)
  57 | NotificationParamsT = TypeVar("NotificationParamsT", bound=NotificationParams)
  58 | MethodT = TypeVar("MethodT", bound=str)
  59 | 
  60 | 
  61 | class Request(BaseModel, Generic[RequestParamsT, MethodT]):
  62 |     """Base class for JSON-RPC requests."""
  63 | 
  64 |     method: MethodT
  65 |     params: RequestParamsT
  66 |     model_config = ConfigDict(extra="allow")
  67 | 
  68 | 
  69 | class PaginatedRequest(Request[RequestParamsT, MethodT]):
  70 |     cursor: Cursor | None = None
  71 |     """
  72 |     An opaque token representing the current pagination position.
  73 |     If provided, the server should return results starting after this cursor.
  74 |     """
  75 | 
  76 | 
  77 | class Notification(BaseModel, Generic[NotificationParamsT, MethodT]):
  78 |     """Base class for JSON-RPC notifications."""
  79 | 
  80 |     method: MethodT
  81 |     model_config = ConfigDict(extra="allow")
  82 | 
  83 | 
  84 | class Result(BaseModel):
  85 |     """Base class for JSON-RPC results."""
  86 | 
  87 |     model_config = ConfigDict(extra="allow")
  88 | 
  89 |     _meta: dict[str, Any] | None = None
  90 |     """
  91 |     This result property is reserved by the protocol to allow clients and servers to
  92 |     attach additional metadata to their responses.
  93 |     """
  94 | 
  95 | 
  96 | class PaginatedResult(Result):
  97 |     nextCursor: Cursor | None = None
  98 |     """
  99 |     An opaque token representing the pagination position after the last returned result.
 100 |     If present, there may be more results available.
 101 |     """
 102 | 
 103 | 
 104 | RequestId = str | int
 105 | 
 106 | 
 107 | class JSONRPCRequest(Request):
 108 |     """A request that expects a response."""
 109 | 
 110 |     jsonrpc: Literal["2.0"]
 111 |     id: RequestId
 112 |     params: dict[str, Any] | None = None
 113 | 
 114 | 
 115 | class JSONRPCNotification(Notification):
 116 |     """A notification which does not expect a response."""
 117 | 
 118 |     jsonrpc: Literal["2.0"]
 119 |     params: dict[str, Any] | None = None
 120 | 
 121 | 
 122 | class JSONRPCResponse(BaseModel):
 123 |     """A successful (non-error) response to a request."""
 124 | 
 125 |     jsonrpc: Literal["2.0"]
 126 |     id: RequestId
 127 |     result: dict[str, Any]
 128 |     model_config = ConfigDict(extra="allow")
 129 | 
 130 | 
 131 | # Standard JSON-RPC error codes
 132 | PARSE_ERROR = -32700
 133 | INVALID_REQUEST = -32600
 134 | METHOD_NOT_FOUND = -32601
 135 | INVALID_PARAMS = -32602
 136 | INTERNAL_ERROR = -32603
 137 | 
 138 | 
 139 | class ErrorData(BaseModel):
 140 |     """Error information for JSON-RPC error responses."""
 141 | 
 142 |     code: int
 143 |     """The error type that occurred."""
 144 | 
 145 |     message: str
 146 |     """
 147 |     A short description of the error. The message SHOULD be limited to a concise single
 148 |     sentence.
 149 |     """
 150 | 
 151 |     data: Any | None = None
 152 |     """
 153 |     Additional information about the error. The value of this member is defined by the
 154 |     sender (e.g. detailed error information, nested errors etc.).
 155 |     """
 156 | 
 157 |     model_config = ConfigDict(extra="allow")
 158 | 
 159 | 
 160 | class JSONRPCError(BaseModel):
 161 |     """A response to a request that indicates an error occurred."""
 162 | 
 163 |     jsonrpc: Literal["2.0"]
 164 |     id: str | int
 165 |     error: ErrorData
 166 |     model_config = ConfigDict(extra="allow")
 167 | 
 168 | 
 169 | class JSONRPCMessage(
 170 |     RootModel[JSONRPCRequest | JSONRPCNotification | JSONRPCResponse | JSONRPCError]
 171 | ):
 172 |     pass
 173 | 
 174 | 
 175 | class EmptyResult(Result):
 176 |     """A response that indicates success but carries no data."""
 177 | 
 178 | 
 179 | class Implementation(BaseModel):
 180 |     """Describes the name and version of an MCP implementation."""
 181 | 
 182 |     name: str
 183 |     version: str
 184 |     model_config = ConfigDict(extra="allow")
 185 | 
 186 | 
 187 | class RootsCapability(BaseModel):
 188 |     """Capability for root operations."""
 189 | 
 190 |     listChanged: bool | None = None
 191 |     """Whether the client supports notifications for changes to the roots list."""
 192 |     model_config = ConfigDict(extra="allow")
 193 | 
 194 | 
 195 | class SamplingCapability(BaseModel):
 196 |     """Capability for logging operations."""
 197 | 
 198 |     model_config = ConfigDict(extra="allow")
 199 | 
 200 | 
 201 | class ClientCapabilities(BaseModel):
 202 |     """Capabilities a client may support."""
 203 | 
 204 |     experimental: dict[str, dict[str, Any]] | None = None
 205 |     """Experimental, non-standard capabilities that the client supports."""
 206 |     sampling: SamplingCapability | None = None
 207 |     """Present if the client supports sampling from an LLM."""
 208 |     roots: RootsCapability | None = None
 209 |     """Present if the client supports listing roots."""
 210 |     model_config = ConfigDict(extra="allow")
 211 | 
 212 | 
 213 | class PromptsCapability(BaseModel):
 214 |     """Capability for prompts operations."""
 215 | 
 216 |     listChanged: bool | None = None
 217 |     """Whether this server supports notifications for changes to the prompt list."""
 218 |     model_config = ConfigDict(extra="allow")
 219 | 
 220 | 
 221 | class ResourcesCapability(BaseModel):
 222 |     """Capability for resources operations."""
 223 | 
 224 |     subscribe: bool | None = None
 225 |     """Whether this server supports subscribing to resource updates."""
 226 |     listChanged: bool | None = None
 227 |     """Whether this server supports notifications for changes to the resource list."""
 228 |     model_config = ConfigDict(extra="allow")
 229 | 
 230 | 
 231 | class ToolsCapability(BaseModel):
 232 |     """Capability for tools operations."""
 233 | 
 234 |     listChanged: bool | None = None
 235 |     """Whether this server supports notifications for changes to the tool list."""
 236 |     model_config = ConfigDict(extra="allow")
 237 | 
 238 | 
 239 | class LoggingCapability(BaseModel):
 240 |     """Capability for logging operations."""
 241 | 
 242 |     model_config = ConfigDict(extra="allow")
 243 | 
 244 | 
 245 | class ServerCapabilities(BaseModel):
 246 |     """Capabilities that a server may support."""
 247 | 
 248 |     experimental: dict[str, dict[str, Any]] | None = None
 249 |     """Experimental, non-standard capabilities that the server supports."""
 250 |     logging: LoggingCapability | None = None
 251 |     """Present if the server supports sending log messages to the client."""
 252 |     prompts: PromptsCapability | None = None
 253 |     """Present if the server offers any prompt templates."""
 254 |     resources: ResourcesCapability | None = None
 255 |     """Present if the server offers any resources to read."""
 256 |     tools: ToolsCapability | None = None
 257 |     """Present if the server offers any tools to call."""
 258 |     model_config = ConfigDict(extra="allow")
 259 | 
 260 | 
 261 | class InitializeRequestParams(RequestParams):
 262 |     """Parameters for the initialize request."""
 263 | 
 264 |     protocolVersion: str | int
 265 |     """The latest version of the Model Context Protocol that the client supports."""
 266 |     capabilities: ClientCapabilities
 267 |     clientInfo: Implementation
 268 |     model_config = ConfigDict(extra="allow")
 269 | 
 270 | 
 271 | class InitializeRequest(Request):
 272 |     """
 273 |     This request is sent from the client to the server when it first connects, asking it
 274 |     to begin initialization.
 275 |     """
 276 | 
 277 |     method: Literal["initialize"]
 278 |     params: InitializeRequestParams
 279 | 
 280 | 
 281 | class InitializeResult(Result):
 282 |     """After receiving an initialize request from the client, the server sends this."""
 283 | 
 284 |     protocolVersion: str | int
 285 |     """The version of the Model Context Protocol that the server wants to use."""
 286 |     capabilities: ServerCapabilities
 287 |     serverInfo: Implementation
 288 | 
 289 | 
 290 | class InitializedNotification(Notification):
 291 |     """
 292 |     This notification is sent from the client to the server after initialization has
 293 |     finished.
 294 |     """
 295 | 
 296 |     method: Literal["notifications/initialized"]
 297 |     params: NotificationParams | None = None
 298 | 
 299 | 
 300 | class PingRequest(Request):
 301 |     """
 302 |     A ping, issued by either the server or the client, to check that the other party is
 303 |     still alive.
 304 |     """
 305 | 
 306 |     method: Literal["ping"]
 307 |     params: RequestParams | None = None
 308 | 
 309 | 
 310 | class ProgressNotificationParams(NotificationParams):
 311 |     """Parameters for progress notifications."""
 312 | 
 313 |     progressToken: ProgressToken
 314 |     """
 315 |     The progress token which was given in the initial request, used to associate this
 316 |     notification with the request that is proceeding.
 317 |     """
 318 |     progress: float
 319 |     """
 320 |     The progress thus far. This should increase every time progress is made, even if the
 321 |     total is unknown.
 322 |     """
 323 |     total: float | None = None
 324 |     """Total number of items to process (or total progress required), if known."""
 325 |     model_config = ConfigDict(extra="allow")
 326 | 
 327 | 
 328 | class ProgressNotification(Notification):
 329 |     """
 330 |     An out-of-band notification used to inform the receiver of a progress update for a
 331 |     long-running request.
 332 |     """
 333 | 
 334 |     method: Literal["notifications/progress"]
 335 |     params: ProgressNotificationParams
 336 | 
 337 | 
 338 | class ListResourcesRequest(PaginatedRequest):
 339 |     """Sent from the client to request a list of resources the server has."""
 340 | 
 341 |     method: Literal["resources/list"]
 342 |     params: RequestParams | None = None
 343 | 
 344 | 
 345 | class Resource(BaseModel):
 346 |     """A known resource that the server is capable of reading."""
 347 | 
 348 |     uri: AnyUrl
 349 |     """The URI of this resource."""
 350 |     name: str
 351 |     """A human-readable name for this resource."""
 352 |     description: str | None = None
 353 |     """A description of what this resource represents."""
 354 |     mimeType: str | None = None
 355 |     """The MIME type of this resource, if known."""
 356 |     model_config = ConfigDict(extra="allow")
 357 | 
 358 | 
 359 | class ResourceTemplate(BaseModel):
 360 |     """A template description for resources available on the server."""
 361 | 
 362 |     uriTemplate: str
 363 |     """
 364 |     A URI template (according to RFC 6570) that can be used to construct resource
 365 |     URIs.
 366 |     """
 367 |     name: str
 368 |     """A human-readable name for the type of resource this template refers to."""
 369 |     description: str | None = None
 370 |     """A human-readable description of what this template is for."""
 371 |     mimeType: str | None = None
 372 |     """
 373 |     The MIME type for all resources that match this template. This should only be
 374 |     included if all resources matching this template have the same type.
 375 |     """
 376 |     model_config = ConfigDict(extra="allow")
 377 | 
 378 | 
 379 | class ListResourcesResult(PaginatedResult):
 380 |     """The server's response to a resources/list request from the client."""
 381 | 
 382 |     resources: list[Resource]
 383 | 
 384 | 
 385 | class ListResourceTemplatesRequest(PaginatedRequest):
 386 |     """Sent from the client to request a list of resource templates the server has."""
 387 | 
 388 |     method: Literal["resources/templates/list"]
 389 |     params: RequestParams | None = None
 390 | 
 391 | 
 392 | class ListResourceTemplatesResult(PaginatedResult):
 393 |     """The server's response to a resources/templates/list request from the client."""
 394 | 
 395 |     resourceTemplates: list[ResourceTemplate]
 396 | 
 397 | 
 398 | class ReadResourceRequestParams(RequestParams):
 399 |     """Parameters for reading a resource."""
 400 | 
 401 |     uri: AnyUrl
 402 |     """
 403 |     The URI of the resource to read. The URI can use any protocol; it is up to the
 404 |     server how to interpret it.
 405 |     """
 406 |     model_config = ConfigDict(extra="allow")
 407 | 
 408 | 
 409 | class ReadResourceRequest(Request):
 410 |     """Sent from the client to the server, to read a specific resource URI."""
 411 | 
 412 |     method: Literal["resources/read"]
 413 |     params: ReadResourceRequestParams
 414 | 
 415 | 
 416 | class ResourceContents(BaseModel):
 417 |     """The contents of a specific resource or sub-resource."""
 418 | 
 419 |     uri: AnyUrl
 420 |     """The URI of this resource."""
 421 |     mimeType: str | None = None
 422 |     """The MIME type of this resource, if known."""
 423 |     model_config = ConfigDict(extra="allow")
 424 | 
 425 | 
 426 | class TextResourceContents(ResourceContents):
 427 |     """Text contents of a resource."""
 428 | 
 429 |     text: str
 430 |     """
 431 |     The text of the item. This must only be set if the item can actually be represented
 432 |     as text (not binary data).
 433 |     """
 434 | 
 435 | 
 436 | class BlobResourceContents(ResourceContents):
 437 |     """Binary contents of a resource."""
 438 | 
 439 |     blob: str
 440 |     """A base64-encoded string representing the binary data of the item."""
 441 | 
 442 | 
 443 | class ReadResourceResult(Result):
 444 |     """The server's response to a resources/read request from the client."""
 445 | 
 446 |     contents: list[TextResourceContents | BlobResourceContents]
 447 | 
 448 | 
 449 | class ResourceListChangedNotification(Notification):
 450 |     """
 451 |     An optional notification from the server to the client, informing it that the list
 452 |     of resources it can read from has changed.
 453 |     """
 454 | 
 455 |     method: Literal["notifications/resources/list_changed"]
 456 |     params: NotificationParams | None = None
 457 | 
 458 | 
 459 | class SubscribeRequestParams(RequestParams):
 460 |     """Parameters for subscribing to a resource."""
 461 | 
 462 |     uri: AnyUrl
 463 |     """
 464 |     The URI of the resource to subscribe to. The URI can use any protocol; it is up to
 465 |     the server how to interpret it.
 466 |     """
 467 |     model_config = ConfigDict(extra="allow")
 468 | 
 469 | 
 470 | class SubscribeRequest(Request):
 471 |     """
 472 |     Sent from the client to request resources/updated notifications from the server
 473 |     whenever a particular resource changes.
 474 |     """
 475 | 
 476 |     method: Literal["resources/subscribe"]
 477 |     params: SubscribeRequestParams
 478 | 
 479 | 
 480 | class UnsubscribeRequestParams(RequestParams):
 481 |     """Parameters for unsubscribing from a resource."""
 482 | 
 483 |     uri: AnyUrl
 484 |     """The URI of the resource to unsubscribe from."""
 485 |     model_config = ConfigDict(extra="allow")
 486 | 
 487 | 
 488 | class UnsubscribeRequest(Request):
 489 |     """
 490 |     Sent from the client to request cancellation of resources/updated notifications from
 491 |     the server.
 492 |     """
 493 | 
 494 |     method: Literal["resources/unsubscribe"]
 495 |     params: UnsubscribeRequestParams
 496 | 
 497 | 
 498 | class ResourceUpdatedNotificationParams(NotificationParams):
 499 |     """Parameters for resource update notifications."""
 500 | 
 501 |     uri: AnyUrl
 502 |     """
 503 |     The URI of the resource that has been updated. This might be a sub-resource of the
 504 |     one that the client actually subscribed to.
 505 |     """
 506 |     model_config = ConfigDict(extra="allow")
 507 | 
 508 | 
 509 | class ResourceUpdatedNotification(Notification):
 510 |     """
 511 |     A notification from the server to the client, informing it that a resource has
 512 |     changed and may need to be read again.
 513 |     """
 514 | 
 515 |     method: Literal["notifications/resources/updated"]
 516 |     params: ResourceUpdatedNotificationParams
 517 | 
 518 | 
 519 | class ListPromptsRequest(PaginatedRequest):
 520 |     """Sent from the client to request a list of prompts and prompt templates."""
 521 | 
 522 |     method: Literal["prompts/list"]
 523 |     params: RequestParams | None = None
 524 | 
 525 | 
 526 | class PromptArgument(BaseModel):
 527 |     """An argument for a prompt template."""
 528 | 
 529 |     name: str
 530 |     """The name of the argument."""
 531 |     description: str | None = None
 532 |     """A human-readable description of the argument."""
 533 |     required: bool | None = None
 534 |     """Whether this argument must be provided."""
 535 |     model_config = ConfigDict(extra="allow")
 536 | 
 537 | 
 538 | class Prompt(BaseModel):
 539 |     """A prompt or prompt template that the server offers."""
 540 | 
 541 |     name: str
 542 |     """The name of the prompt or prompt template."""
 543 |     description: str | None = None
 544 |     """An optional description of what this prompt provides."""
 545 |     arguments: list[PromptArgument] | None = None
 546 |     """A list of arguments to use for templating the prompt."""
 547 |     model_config = ConfigDict(extra="allow")
 548 | 
 549 | 
 550 | class ListPromptsResult(PaginatedResult):
 551 |     """The server's response to a prompts/list request from the client."""
 552 | 
 553 |     prompts: list[Prompt]
 554 | 
 555 | 
 556 | class GetPromptRequestParams(RequestParams):
 557 |     """Parameters for getting a prompt."""
 558 | 
 559 |     name: str
 560 |     """The name of the prompt or prompt template."""
 561 |     arguments: dict[str, str] | None = None
 562 |     """Arguments to use for templating the prompt."""
 563 |     model_config = ConfigDict(extra="allow")
 564 | 
 565 | 
 566 | class GetPromptRequest(Request):
 567 |     """Used by the client to get a prompt provided by the server."""
 568 | 
 569 |     method: Literal["prompts/get"]
 570 |     params: GetPromptRequestParams
 571 | 
 572 | 
 573 | class TextContent(BaseModel):
 574 |     """Text content for a message."""
 575 | 
 576 |     type: Literal["text"]
 577 |     text: str
 578 |     """The text content of the message."""
 579 |     model_config = ConfigDict(extra="allow")
 580 | 
 581 | 
 582 | class ImageContent(BaseModel):
 583 |     """Image content for a message."""
 584 | 
 585 |     type: Literal["image"]
 586 |     data: str
 587 |     """The base64-encoded image data."""
 588 |     mimeType: str
 589 |     """
 590 |     The MIME type of the image. Different providers may support different
 591 |     image types.
 592 |     """
 593 |     model_config = ConfigDict(extra="allow")
 594 | 
 595 | 
 596 | Role = Literal["user", "assistant"]
 597 | 
 598 | 
 599 | class SamplingMessage(BaseModel):
 600 |     """Describes a message issued to or received from an LLM API."""
 601 | 
 602 |     role: Role
 603 |     content: TextContent | ImageContent
 604 |     model_config = ConfigDict(extra="allow")
 605 | 
 606 | 
 607 | class EmbeddedResource(BaseModel):
 608 |     """
 609 |     The contents of a resource, embedded into a prompt or tool call result.
 610 | 
 611 |     It is up to the client how best to render embedded resources for the benefit
 612 |     of the LLM and/or the user.
 613 |     """
 614 | 
 615 |     type: Literal["resource"]
 616 |     resource: TextResourceContents | BlobResourceContents
 617 |     model_config = ConfigDict(extra="allow")
 618 | 
 619 | 
 620 | class PromptMessage(BaseModel):
 621 |     """Describes a message returned as part of a prompt."""
 622 | 
 623 |     role: Role
 624 |     content: TextContent | ImageContent | EmbeddedResource
 625 |     model_config = ConfigDict(extra="allow")
 626 | 
 627 | 
 628 | class GetPromptResult(Result):
 629 |     """The server's response to a prompts/get request from the client."""
 630 | 
 631 |     description: str | None = None
 632 |     """An optional description for the prompt."""
 633 |     messages: list[PromptMessage]
 634 | 
 635 | 
 636 | class PromptListChangedNotification(Notification):
 637 |     """
 638 |     An optional notification from the server to the client, informing it that the list
 639 |     of prompts it offers has changed.
 640 |     """
 641 | 
 642 |     method: Literal["notifications/prompts/list_changed"]
 643 |     params: NotificationParams | None = None
 644 | 
 645 | 
 646 | class ListToolsRequest(PaginatedRequest):
 647 |     """Sent from the client to request a list of tools the server has."""
 648 | 
 649 |     method: Literal["tools/list"]
 650 |     params: RequestParams | None = None
 651 | 
 652 | 
 653 | class Tool(BaseModel):
 654 |     """Definition for a tool the client can call."""
 655 | 
 656 |     name: str
 657 |     """The name of the tool."""
 658 |     description: str | None = None
 659 |     """A human-readable description of the tool."""
 660 |     inputSchema: dict[str, Any]
 661 |     """A JSON Schema object defining the expected parameters for the tool."""
 662 |     model_config = ConfigDict(extra="allow")
 663 | 
 664 | 
 665 | class ListToolsResult(PaginatedResult):
 666 |     """The server's response to a tools/list request from the client."""
 667 | 
 668 |     tools: list[Tool]
 669 | 
 670 | 
 671 | class CallToolRequestParams(RequestParams):
 672 |     """Parameters for calling a tool."""
 673 | 
 674 |     name: str
 675 |     arguments: dict[str, Any] | None = None
 676 |     model_config = ConfigDict(extra="allow")
 677 | 
 678 | 
 679 | class CallToolRequest(Request):
 680 |     """Used by the client to invoke a tool provided by the server."""
 681 | 
 682 |     method: Literal["tools/call"]
 683 |     params: CallToolRequestParams
 684 | 
 685 | 
 686 | class CallToolResult(Result):
 687 |     """The server's response to a tool call."""
 688 | 
 689 |     content: list[TextContent | ImageContent | EmbeddedResource]
 690 |     isError: bool = False
 691 | 
 692 | 
 693 | class ToolListChangedNotification(Notification):
 694 |     """
 695 |     An optional notification from the server to the client, informing it that the list
 696 |     of tools it offers has changed.
 697 |     """
 698 | 
 699 |     method: Literal["notifications/tools/list_changed"]
 700 |     params: NotificationParams | None = None
 701 | 
 702 | 
 703 | LoggingLevel = Literal[
 704 |     "debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"
 705 | ]
 706 | 
 707 | 
 708 | class SetLevelRequestParams(RequestParams):
 709 |     """Parameters for setting the logging level."""
 710 | 
 711 |     level: LoggingLevel
 712 |     """The level of logging that the client wants to receive from the server."""
 713 |     model_config = ConfigDict(extra="allow")
 714 | 
 715 | 
 716 | class SetLevelRequest(Request):
 717 |     """A request from the client to the server, to enable or adjust logging."""
 718 | 
 719 |     method: Literal["logging/setLevel"]
 720 |     params: SetLevelRequestParams
 721 | 
 722 | 
 723 | class LoggingMessageNotificationParams(NotificationParams):
 724 |     """Parameters for logging message notifications."""
 725 | 
 726 |     level: LoggingLevel
 727 |     """The severity of this log message."""
 728 |     logger: str | None = None
 729 |     """An optional name of the logger issuing this message."""
 730 |     data: Any
 731 |     """
 732 |     The data to be logged, such as a string message or an object. Any JSON serializable
 733 |     type is allowed here.
 734 |     """
 735 |     model_config = ConfigDict(extra="allow")
 736 | 
 737 | 
 738 | class LoggingMessageNotification(Notification):
 739 |     """Notification of a log message passed from server to client."""
 740 | 
 741 |     method: Literal["notifications/message"]
 742 |     params: LoggingMessageNotificationParams
 743 | 
 744 | 
 745 | IncludeContext = Literal["none", "thisServer", "allServers"]
 746 | 
 747 | 
 748 | class ModelHint(BaseModel):
 749 |     """Hints to use for model selection."""
 750 | 
 751 |     name: str | None = None
 752 |     """A hint for a model name."""
 753 | 
 754 |     model_config = ConfigDict(extra="allow")
 755 | 
 756 | 
 757 | class ModelPreferences(BaseModel):
 758 |     """
 759 |     The server's preferences for model selection, requested of the client during
 760 |     sampling.
 761 | 
 762 |     Because LLMs can vary along multiple dimensions, choosing the "best" model is
 763 |     rarely straightforward.  Different models excel in different areas—some are
 764 |     faster but less capable, others are more capable but more expensive, and so
 765 |     on. This interface allows servers to express their priorities across multiple
 766 |     dimensions to help clients make an appropriate selection for their use case.
 767 | 
 768 |     These preferences are always advisory. The client MAY ignore them. It is also
 769 |     up to the client to decide how to interpret these preferences and how to
 770 |     balance them against other considerations.
 771 |     """
 772 | 
 773 |     hints: list[ModelHint] | None = None
 774 |     """
 775 |     Optional hints to use for model selection.
 776 | 
 777 |     If multiple hints are specified, the client MUST evaluate them in order
 778 |     (such that the first match is taken).
 779 | 
 780 |     The client SHOULD prioritize these hints over the numeric priorities, but
 781 |     MAY still use the priorities to select from ambiguous matches.
 782 |     """
 783 | 
 784 |     costPriority: float | None = None
 785 |     """
 786 |     How much to prioritize cost when selecting a model. A value of 0 means cost
 787 |     is not important, while a value of 1 means cost is the most important
 788 |     factor.
 789 |     """
 790 | 
 791 |     speedPriority: float | None = None
 792 |     """
 793 |     How much to prioritize sampling speed (latency) when selecting a model. A
 794 |     value of 0 means speed is not important, while a value of 1 means speed is
 795 |     the most important factor.
 796 |     """
 797 | 
 798 |     intelligencePriority: float | None = None
 799 |     """
 800 |     How much to prioritize intelligence and capabilities when selecting a
 801 |     model. A value of 0 means intelligence is not important, while a value of 1
 802 |     means intelligence is the most important factor.
 803 |     """
 804 | 
 805 |     model_config = ConfigDict(extra="allow")
 806 | 
 807 | 
 808 | class CreateMessageRequestParams(RequestParams):
 809 |     """Parameters for creating a message."""
 810 | 
 811 |     messages: list[SamplingMessage]
 812 |     modelPreferences: ModelPreferences | None = None
 813 |     """
 814 |     The server's preferences for which model to select. The client MAY ignore
 815 |     these preferences.
 816 |     """
 817 |     systemPrompt: str | None = None
 818 |     """An optional system prompt the server wants to use for sampling."""
 819 |     includeContext: IncludeContext | None = None
 820 |     """
 821 |     A request to include context from one or more MCP servers (including the caller), to
 822 |     be attached to the prompt.
 823 |     """
 824 |     temperature: float | None = None
 825 |     maxTokens: int
 826 |     """The maximum number of tokens to sample, as requested by the server."""
 827 |     stopSequences: list[str] | None = None
 828 |     metadata: dict[str, Any] | None = None
 829 |     """Optional metadata to pass through to the LLM provider."""
 830 |     model_config = ConfigDict(extra="allow")
 831 | 
 832 | 
 833 | class CreateMessageRequest(Request):
 834 |     """A request from the server to sample an LLM via the client."""
 835 | 
 836 |     method: Literal["sampling/createMessage"]
 837 |     params: CreateMessageRequestParams
 838 | 
 839 | 
 840 | StopReason = Literal["endTurn", "stopSequence", "maxTokens"] | str
 841 | 
 842 | 
 843 | class CreateMessageResult(Result):
 844 |     """The client's response to a sampling/create_message request from the server."""
 845 | 
 846 |     role: Role
 847 |     content: TextContent | ImageContent
 848 |     model: str
 849 |     """The name of the model that generated the message."""
 850 |     stopReason: StopReason | None = None
 851 |     """The reason why sampling stopped, if known."""
 852 | 
 853 | 
 854 | class ResourceReference(BaseModel):
 855 |     """A reference to a resource or resource template definition."""
 856 | 
 857 |     type: Literal["ref/resource"]
 858 |     uri: str
 859 |     """The URI or URI template of the resource."""
 860 |     model_config = ConfigDict(extra="allow")
 861 | 
 862 | 
 863 | class PromptReference(BaseModel):
 864 |     """Identifies a prompt."""
 865 | 
 866 |     type: Literal["ref/prompt"]
 867 |     name: str
 868 |     """The name of the prompt or prompt template"""
 869 |     model_config = ConfigDict(extra="allow")
 870 | 
 871 | 
 872 | class CompletionArgument(BaseModel):
 873 |     """The argument's information for completion requests."""
 874 | 
 875 |     name: str
 876 |     """The name of the argument"""
 877 |     value: str
 878 |     """The value of the argument to use for completion matching."""
 879 |     model_config = ConfigDict(extra="allow")
 880 | 
 881 | 
 882 | class CompleteRequestParams(RequestParams):
 883 |     """Parameters for completion requests."""
 884 | 
 885 |     ref: ResourceReference | PromptReference
 886 |     argument: CompletionArgument
 887 |     model_config = ConfigDict(extra="allow")
 888 | 
 889 | 
 890 | class CompleteRequest(Request):
 891 |     """A request from the client to the server, to ask for completion options."""
 892 | 
 893 |     method: Literal["completion/complete"]
 894 |     params: CompleteRequestParams
 895 | 
 896 | 
 897 | class Completion(BaseModel):
 898 |     """Completion information."""
 899 | 
 900 |     values: list[str]
 901 |     """An array of completion values. Must not exceed 100 items."""
 902 |     total: int | None = None
 903 |     """
 904 |     The total number of completion options available. This can exceed the number of
 905 |     values actually sent in the response.
 906 |     """
 907 |     hasMore: bool | None = None
 908 |     """
 909 |     Indicates whether there are additional completion options beyond those provided in
 910 |     the current response, even if the exact total is unknown.
 911 |     """
 912 |     model_config = ConfigDict(extra="allow")
 913 | 
 914 | 
 915 | class CompleteResult(Result):
 916 |     """The server's response to a completion/complete request"""
 917 | 
 918 |     completion: Completion
 919 | 
 920 | 
 921 | class ListRootsRequest(Request):
 922 |     """
 923 |     Sent from the server to request a list of root URIs from the client. Roots allow
 924 |     servers to ask for specific directories or files to operate on. A common example
 925 |     for roots is providing a set of repositories or directories a server should operate
 926 |     on.
 927 | 
 928 |     This request is typically used when the server needs to understand the file system
 929 |     structure or access specific locations that the client has permission to read from.
 930 |     """
 931 | 
 932 |     method: Literal["roots/list"]
 933 |     params: RequestParams | None = None
 934 | 
 935 | 
 936 | class Root(BaseModel):
 937 |     """Represents a root directory or file that the server can operate on."""
 938 | 
 939 |     uri: FileUrl
 940 |     """
 941 |     The URI identifying the root. This *must* start with file:// for now.
 942 |     This restriction may be relaxed in future versions of the protocol to allow
 943 |     other URI schemes.
 944 |     """
 945 |     name: str | None = None
 946 |     """
 947 |     An optional name for the root. This can be used to provide a human-readable
 948 |     identifier for the root, which may be useful for display purposes or for
 949 |     referencing the root in other parts of the application.
 950 |     """
 951 |     model_config = ConfigDict(extra="allow")
 952 | 
 953 | 
 954 | class ListRootsResult(Result):
 955 |     """
 956 |     The client's response to a roots/list request from the server.
 957 |     This result contains an array of Root objects, each representing a root directory
 958 |     or file that the server can operate on.
 959 |     """
 960 | 
 961 |     roots: list[Root]
 962 | 
 963 | 
 964 | class RootsListChangedNotification(Notification):
 965 |     """
 966 |     A notification from the client to the server, informing it that the list of
 967 |     roots has changed.
 968 | 
 969 |     This notification should be sent whenever the client adds, removes, or
 970 |     modifies any root. The server should then request an updated list of roots
 971 |     using the ListRootsRequest.
 972 |     """
 973 | 
 974 |     method: Literal["notifications/roots/list_changed"]
 975 |     params: NotificationParams | None = None
 976 | 
 977 | 
 978 | class ClientRequest(
 979 |     RootModel[
 980 |         PingRequest
 981 |         | InitializeRequest
 982 |         | CompleteRequest
 983 |         | SetLevelRequest
 984 |         | GetPromptRequest
 985 |         | ListPromptsRequest
 986 |         | ListResourcesRequest
 987 |         | ListResourceTemplatesRequest
 988 |         | ReadResourceRequest
 989 |         | SubscribeRequest
 990 |         | UnsubscribeRequest
 991 |         | CallToolRequest
 992 |         | ListToolsRequest
 993 |     ]
 994 | ):
 995 |     pass
 996 | 
 997 | 
 998 | class ClientNotification(
 999 |     RootModel[
1000 |         ProgressNotification | InitializedNotification | RootsListChangedNotification
1001 |     ]
1002 | ):
1003 |     pass
1004 | 
1005 | 
1006 | class ClientResult(RootModel[EmptyResult | CreateMessageResult | ListRootsResult]):
1007 |     pass
1008 | 
1009 | 
1010 | class ServerRequest(RootModel[PingRequest | CreateMessageRequest | ListRootsRequest]):
1011 |     pass
1012 | 
1013 | 
1014 | class ServerNotification(
1015 |     RootModel[
1016 |         ProgressNotification
1017 |         | LoggingMessageNotification
1018 |         | ResourceUpdatedNotification
1019 |         | ResourceListChangedNotification
1020 |         | ToolListChangedNotification
1021 |         | PromptListChangedNotification
1022 |     ]
1023 | ):
1024 |     pass
1025 | 
1026 | 
1027 | class ServerResult(
1028 |     RootModel[
1029 |         EmptyResult
1030 |         | InitializeResult
1031 |         | CompleteResult
1032 |         | GetPromptResult
1033 |         | ListPromptsResult
1034 |         | ListResourcesResult
1035 |         | ListResourceTemplatesResult
1036 |         | ReadResourceResult
1037 |         | CallToolResult
1038 |         | ListToolsResult
1039 |     ]
1040 | ):
1041 |     pass
1042 | 


--------------------------------------------------------------------------------
/tests/__init__.py:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/aaf32b530738ff79ba607c2884374243350f521c/tests/__init__.py


--------------------------------------------------------------------------------
/tests/client/__init__.py:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/aaf32b530738ff79ba607c2884374243350f521c/tests/client/__init__.py


--------------------------------------------------------------------------------
/tests/client/test_session.py:
--------------------------------------------------------------------------------
 1 | import anyio
 2 | import pytest
 3 | 
 4 | from mcp.client.session import ClientSession
 5 | from mcp.types import (
 6 |     LATEST_PROTOCOL_VERSION,
 7 |     ClientNotification,
 8 |     ClientRequest,
 9 |     Implementation,
10 |     InitializedNotification,
11 |     InitializeRequest,
12 |     InitializeResult,
13 |     JSONRPCMessage,
14 |     JSONRPCNotification,
15 |     JSONRPCRequest,
16 |     JSONRPCResponse,
17 |     ServerCapabilities,
18 |     ServerResult,
19 | )
20 | 
21 | 
22 | @pytest.mark.anyio
23 | async def test_client_session_initialize():
24 |     client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream[
25 |         JSONRPCMessage
26 |     ](1)
27 |     server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream[
28 |         JSONRPCMessage
29 |     ](1)
30 | 
31 |     initialized_notification = None
32 | 
33 |     async def mock_server():
34 |         nonlocal initialized_notification
35 | 
36 |         jsonrpc_request = await client_to_server_receive.receive()
37 |         assert isinstance(jsonrpc_request.root, JSONRPCRequest)
38 |         request = ClientRequest.model_validate(
39 |             jsonrpc_request.model_dump(by_alias=True, mode="json", exclude_none=True)
40 |         )
41 |         assert isinstance(request.root, InitializeRequest)
42 | 
43 |         result = ServerResult(
44 |             InitializeResult(
45 |                 protocolVersion=LATEST_PROTOCOL_VERSION,
46 |                 capabilities=ServerCapabilities(
47 |                     logging=None,
48 |                     resources=None,
49 |                     tools=None,
50 |                     experimental=None,
51 |                     prompts=None,
52 |                 ),
53 |                 serverInfo=Implementation(name="mock-server", version="0.1.0"),
54 |             )
55 |         )
56 | 
57 |         async with server_to_client_send:
58 |             await server_to_client_send.send(
59 |                 JSONRPCMessage(
60 |                     JSONRPCResponse(
61 |                         jsonrpc="2.0",
62 |                         id=jsonrpc_request.root.id,
63 |                         result=result.model_dump(
64 |                             by_alias=True, mode="json", exclude_none=True
65 |                         ),
66 |                     )
67 |                 )
68 |             )
69 |             jsonrpc_notification = await client_to_server_receive.receive()
70 |             assert isinstance(jsonrpc_notification.root, JSONRPCNotification)
71 |             initialized_notification = ClientNotification.model_validate(
72 |                 jsonrpc_notification.model_dump(
73 |                     by_alias=True, mode="json", exclude_none=True
74 |                 )
75 |             )
76 | 
77 |     async def listen_session():
78 |         async for message in session.incoming_messages:
79 |             if isinstance(message, Exception):
80 |                 raise message
81 | 
82 |     async with (
83 |         ClientSession(server_to_client_receive, client_to_server_send) as session,
84 |         anyio.create_task_group() as tg,
85 |     ):
86 |         tg.start_soon(mock_server)
87 |         tg.start_soon(listen_session)
88 |         result = await session.initialize()
89 | 
90 |     # Assert the result
91 |     assert isinstance(result, InitializeResult)
92 |     assert result.protocolVersion == LATEST_PROTOCOL_VERSION
93 |     assert isinstance(result.capabilities, ServerCapabilities)
94 |     assert result.serverInfo == Implementation(name="mock-server", version="0.1.0")
95 | 
96 |     # Check that the client sent the initialized notification
97 |     assert initialized_notification
98 |     assert isinstance(initialized_notification.root, InitializedNotification)
99 | 


--------------------------------------------------------------------------------
/tests/client/test_stdio.py:
--------------------------------------------------------------------------------
 1 | import pytest
 2 | 
 3 | from mcp.client.stdio import StdioServerParameters, stdio_client
 4 | from mcp.types import JSONRPCMessage, JSONRPCRequest, JSONRPCResponse
 5 | 
 6 | 
 7 | @pytest.mark.anyio
 8 | async def test_stdio_client():
 9 |     server_parameters = StdioServerParameters(command="/usr/bin/tee")
10 | 
11 |     async with stdio_client(server_parameters) as (read_stream, write_stream):
12 |         # Test sending and receiving messages
13 |         messages = [
14 |             JSONRPCMessage(root=JSONRPCRequest(jsonrpc="2.0", id=1, method="ping")),
15 |             JSONRPCMessage(root=JSONRPCResponse(jsonrpc="2.0", id=2, result={})),
16 |         ]
17 | 
18 |         async with write_stream:
19 |             for message in messages:
20 |                 await write_stream.send(message)
21 | 
22 |         read_messages = []
23 |         async with read_stream:
24 |             async for message in read_stream:
25 |                 if isinstance(message, Exception):
26 |                     raise message
27 | 
28 |                 read_messages.append(message)
29 |                 if len(read_messages) == 2:
30 |                     break
31 | 
32 |         assert len(read_messages) == 2
33 |         assert read_messages[0] == JSONRPCMessage(
34 |             root=JSONRPCRequest(jsonrpc="2.0", id=1, method="ping")
35 |         )
36 |         assert read_messages[1] == JSONRPCMessage(
37 |             root=JSONRPCResponse(jsonrpc="2.0", id=2, result={})
38 |         )
39 | 


--------------------------------------------------------------------------------
/tests/conftest.py:
--------------------------------------------------------------------------------
 1 | import pytest
 2 | from pydantic import AnyUrl
 3 | 
 4 | from mcp.server import Server
 5 | from mcp.server.models import InitializationOptions
 6 | from mcp.types import Resource, ServerCapabilities
 7 | 
 8 | TEST_INITIALIZATION_OPTIONS = InitializationOptions(
 9 |     server_name="my_mcp_server",
10 |     server_version="0.1.0",
11 |     capabilities=ServerCapabilities(),
12 | )
13 | 
14 | 
15 | @pytest.fixture
16 | def mcp_server() -> Server:
17 |     server = Server(name="test_server")
18 | 
19 |     @server.list_resources()
20 |     async def handle_list_resources():
21 |         return [
22 |             Resource(
23 |                 uri=AnyUrl("memory://test"),
24 |                 name="Test Resource",
25 |                 description="A test resource",
26 |             )
27 |         ]
28 | 
29 |     return server
30 | 


--------------------------------------------------------------------------------
/tests/server/__init__.py:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/aaf32b530738ff79ba607c2884374243350f521c/tests/server/__init__.py


--------------------------------------------------------------------------------
/tests/server/test_session.py:
--------------------------------------------------------------------------------
  1 | import anyio
  2 | import pytest
  3 | 
  4 | from mcp.client.session import ClientSession
  5 | from mcp.server import NotificationOptions, Server
  6 | from mcp.server.models import InitializationOptions
  7 | from mcp.server.session import ServerSession
  8 | from mcp.types import (
  9 |     ClientNotification,
 10 |     InitializedNotification,
 11 |     JSONRPCMessage,
 12 |     PromptsCapability,
 13 |     ResourcesCapability,
 14 |     ServerCapabilities,
 15 | )
 16 | 
 17 | 
 18 | @pytest.mark.anyio
 19 | async def test_server_session_initialize():
 20 |     server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream(
 21 |         1, JSONRPCMessage
 22 |     )
 23 |     client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream(
 24 |         1, JSONRPCMessage
 25 |     )
 26 | 
 27 |     async def run_client(client: ClientSession):
 28 |         async for message in client_session.incoming_messages:
 29 |             if isinstance(message, Exception):
 30 |                 raise message
 31 | 
 32 |     received_initialized = False
 33 | 
 34 |     async def run_server():
 35 |         nonlocal received_initialized
 36 | 
 37 |         async with ServerSession(
 38 |             client_to_server_receive,
 39 |             server_to_client_send,
 40 |             InitializationOptions(
 41 |                 server_name="mcp",
 42 |                 server_version="0.1.0",
 43 |                 capabilities=ServerCapabilities(),
 44 |             ),
 45 |         ) as server_session:
 46 |             async for message in server_session.incoming_messages:
 47 |                 if isinstance(message, Exception):
 48 |                     raise message
 49 | 
 50 |                 if isinstance(message, ClientNotification) and isinstance(
 51 |                     message.root, InitializedNotification
 52 |                 ):
 53 |                     received_initialized = True
 54 |                     return
 55 | 
 56 |     try:
 57 |         async with (
 58 |             ClientSession(
 59 |                 server_to_client_receive, client_to_server_send
 60 |             ) as client_session,
 61 |             anyio.create_task_group() as tg,
 62 |         ):
 63 |             tg.start_soon(run_client, client_session)
 64 |             tg.start_soon(run_server)
 65 | 
 66 |             await client_session.initialize()
 67 |     except anyio.ClosedResourceError:
 68 |         pass
 69 | 
 70 |     assert received_initialized
 71 | 
 72 | 
 73 | @pytest.mark.anyio
 74 | async def test_server_capabilities():
 75 |     server = Server("test")
 76 |     notification_options = NotificationOptions()
 77 |     experimental_capabilities = {}
 78 | 
 79 |     # Initially no capabilities
 80 |     caps = server.get_capabilities(notification_options, experimental_capabilities)
 81 |     assert caps.prompts is None
 82 |     assert caps.resources is None
 83 | 
 84 |     # Add a prompts handler
 85 |     @server.list_prompts()
 86 |     async def list_prompts():
 87 |         return []
 88 | 
 89 |     caps = server.get_capabilities(notification_options, experimental_capabilities)
 90 |     assert caps.prompts == PromptsCapability(listChanged=False)
 91 |     assert caps.resources is None
 92 | 
 93 |     # Add a resources handler
 94 |     @server.list_resources()
 95 |     async def list_resources():
 96 |         return []
 97 | 
 98 |     caps = server.get_capabilities(notification_options, experimental_capabilities)
 99 |     assert caps.prompts == PromptsCapability(listChanged=False)
100 |     assert caps.resources == ResourcesCapability(subscribe=False, listChanged=False)
101 | 


--------------------------------------------------------------------------------
/tests/server/test_stdio.py:
--------------------------------------------------------------------------------
 1 | import io
 2 | 
 3 | import anyio
 4 | import pytest
 5 | 
 6 | from mcp.server.stdio import stdio_server
 7 | from mcp.types import JSONRPCMessage, JSONRPCRequest, JSONRPCResponse
 8 | 
 9 | 
10 | @pytest.mark.anyio
11 | async def test_stdio_server():
12 |     stdin = io.StringIO()
13 |     stdout = io.StringIO()
14 | 
15 |     messages = [
16 |         JSONRPCMessage(root=JSONRPCRequest(jsonrpc="2.0", id=1, method="ping")),
17 |         JSONRPCMessage(root=JSONRPCResponse(jsonrpc="2.0", id=2, result={})),
18 |     ]
19 | 
20 |     for message in messages:
21 |         stdin.write(message.model_dump_json(by_alias=True, exclude_none=True) + "\n")
22 |     stdin.seek(0)
23 | 
24 |     async with stdio_server(
25 |         stdin=anyio.AsyncFile(stdin), stdout=anyio.AsyncFile(stdout)
26 |     ) as (read_stream, write_stream):
27 |         received_messages = []
28 |         async with read_stream:
29 |             async for message in read_stream:
30 |                 if isinstance(message, Exception):
31 |                     raise message
32 |                 received_messages.append(message)
33 |                 if len(received_messages) == 2:
34 |                     break
35 | 
36 |         # Verify received messages
37 |         assert len(received_messages) == 2
38 |         assert received_messages[0] == JSONRPCMessage(
39 |             root=JSONRPCRequest(jsonrpc="2.0", id=1, method="ping")
40 |         )
41 |         assert received_messages[1] == JSONRPCMessage(
42 |             root=JSONRPCResponse(jsonrpc="2.0", id=2, result={})
43 |         )
44 | 
45 |         # Test sending responses from the server
46 |         responses = [
47 |             JSONRPCMessage(root=JSONRPCRequest(jsonrpc="2.0", id=3, method="ping")),
48 |             JSONRPCMessage(root=JSONRPCResponse(jsonrpc="2.0", id=4, result={})),
49 |         ]
50 | 
51 |         async with write_stream:
52 |             for response in responses:
53 |                 await write_stream.send(response)
54 | 
55 |     stdout.seek(0)
56 |     output_lines = stdout.readlines()
57 |     assert len(output_lines) == 2
58 | 
59 |     received_responses = [
60 |         JSONRPCMessage.model_validate_json(line.strip()) for line in output_lines
61 |     ]
62 |     assert len(received_responses) == 2
63 |     assert received_responses[0] == JSONRPCMessage(
64 |         root=JSONRPCRequest(jsonrpc="2.0", id=3, method="ping")
65 |     )
66 |     assert received_responses[1] == JSONRPCMessage(
67 |         root=JSONRPCResponse(jsonrpc="2.0", id=4, result={})
68 |     )
69 | 


--------------------------------------------------------------------------------
/tests/shared/test_memory.py:
--------------------------------------------------------------------------------
 1 | import pytest
 2 | from typing_extensions import AsyncGenerator
 3 | 
 4 | from mcp.client.session import ClientSession
 5 | from mcp.server import Server
 6 | from mcp.shared.memory import (
 7 |     create_connected_server_and_client_session,
 8 | )
 9 | from mcp.types import (
10 |     EmptyResult,
11 | )
12 | 
13 | 
14 | @pytest.fixture
15 | async def client_connected_to_server(
16 |     mcp_server: Server,
17 | ) -> AsyncGenerator[ClientSession, None]:
18 |     async with create_connected_server_and_client_session(mcp_server) as client_session:
19 |         yield client_session
20 | 
21 | 
22 | @pytest.mark.anyio
23 | async def test_memory_server_and_client_connection(
24 |     client_connected_to_server: ClientSession,
25 | ):
26 |     """Shows how a client and server can communicate over memory streams."""
27 |     response = await client_connected_to_server.send_ping()
28 |     assert isinstance(response, EmptyResult)
29 | 


--------------------------------------------------------------------------------
/tests/test_types.py:
--------------------------------------------------------------------------------
 1 | from mcp.types import (
 2 |     LATEST_PROTOCOL_VERSION,
 3 |     ClientRequest,
 4 |     JSONRPCMessage,
 5 |     JSONRPCRequest,
 6 | )
 7 | 
 8 | 
 9 | def test_jsonrpc_request():
10 |     json_data = {
11 |         "jsonrpc": "2.0",
12 |         "id": 1,
13 |         "method": "initialize",
14 |         "params": {
15 |             "protocolVersion": LATEST_PROTOCOL_VERSION,
16 |             "capabilities": {"batch": None, "sampling": None},
17 |             "clientInfo": {"name": "mcp", "version": "0.1.0"},
18 |         },
19 |     }
20 | 
21 |     request = JSONRPCMessage.model_validate(json_data)
22 |     assert isinstance(request.root, JSONRPCRequest)
23 |     ClientRequest.model_validate(request.model_dump(by_alias=True, exclude_none=True))
24 | 
25 |     assert request.root.jsonrpc == "2.0"
26 |     assert request.root.id == 1
27 |     assert request.root.method == "initialize"
28 |     assert request.root.params is not None
29 |     assert request.root.params["protocolVersion"] == LATEST_PROTOCOL_VERSION
30 | 


--------------------------------------------------------------------------------
/uv.lock:
--------------------------------------------------------------------------------
  1 | version = 1
  2 | requires-python = ">=3.10"
  3 | 
  4 | [options]
  5 | resolution-mode = "lowest-direct"
  6 | 
  7 | [manifest]
  8 | members = [
  9 |     "mcp",
 10 |     "mcp-simple-prompt",
 11 |     "mcp-simple-resource",
 12 |     "mcp-simple-tool",
 13 | ]
 14 | 
 15 | [[package]]
 16 | name = "annotated-types"
 17 | version = "0.7.0"
 18 | source = { registry = "https://pypi.org/simple" }
 19 | sdist = { url = "https://files.pythonhosted.org/packages/ee/67/531ea369ba64dcff5ec9c3402f9f51bf748cec26dde048a2f973a4eea7f5/annotated_types-0.7.0.tar.gz", hash = "sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89", size = 16081 }
 20 | wheels = [
 21 |     { url = "https://files.pythonhosted.org/packages/78/b6/6307fbef88d9b5ee7421e68d78a9f162e0da4900bc5f5793f6d3d0e34fb8/annotated_types-0.7.0-py3-none-any.whl", hash = "sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53", size = 13643 },
 22 | ]
 23 | 
 24 | [[package]]
 25 | name = "anyio"
 26 | version = "4.5.0"
 27 | source = { registry = "https://pypi.org/simple" }
 28 | dependencies = [
 29 |     { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
 30 |     { name = "idna" },
 31 |     { name = "sniffio" },
 32 |     { name = "typing-extensions", marker = "python_full_version < '3.11'" },
 33 | ]
 34 | sdist = { url = "https://files.pythonhosted.org/packages/a0/44/66874c5256e9fbc30103b31927fd9341c8da6ccafd4721b2b3e81e6ef176/anyio-4.5.0.tar.gz", hash = "sha256:c5a275fe5ca0afd788001f58fca1e69e29ce706d746e317d660e21f70c530ef9", size = 169376 }
 35 | wheels = [
 36 |     { url = "https://files.pythonhosted.org/packages/3b/68/f9e9bf6324c46e6b8396610aef90ad423ec3e18c9079547ceafea3dce0ec/anyio-4.5.0-py3-none-any.whl", hash = "sha256:fdeb095b7cc5a5563175eedd926ec4ae55413bb4be5770c424af0ba46ccb4a78", size = 89250 },
 37 | ]
 38 | 
 39 | [[package]]
 40 | name = "attrs"
 41 | version = "24.2.0"
 42 | source = { registry = "https://pypi.org/simple" }
 43 | sdist = { url = "https://files.pythonhosted.org/packages/fc/0f/aafca9af9315aee06a89ffde799a10a582fe8de76c563ee80bbcdc08b3fb/attrs-24.2.0.tar.gz", hash = "sha256:5cfb1b9148b5b086569baec03f20d7b6bf3bcacc9a42bebf87ffaaca362f6346", size = 792678 }
 44 | wheels = [
 45 |     { url = "https://files.pythonhosted.org/packages/6a/21/5b6702a7f963e95456c0de2d495f67bf5fd62840ac655dc451586d23d39a/attrs-24.2.0-py3-none-any.whl", hash = "sha256:81921eb96de3191c8258c199618104dd27ac608d9366f5e35d011eae1867ede2", size = 63001 },
 46 | ]
 47 | 
 48 | [[package]]
 49 | name = "certifi"
 50 | version = "2024.8.30"
 51 | source = { registry = "https://pypi.org/simple" }
 52 | sdist = { url = "https://files.pythonhosted.org/packages/b0/ee/9b19140fe824b367c04c5e1b369942dd754c4c5462d5674002f75c4dedc1/certifi-2024.8.30.tar.gz", hash = "sha256:bec941d2aa8195e248a60b31ff9f0558284cf01a52591ceda73ea9afffd69fd9", size = 168507 }
 53 | wheels = [
 54 |     { url = "https://files.pythonhosted.org/packages/12/90/3c9ff0512038035f59d279fddeb79f5f1eccd8859f06d6163c58798b9487/certifi-2024.8.30-py3-none-any.whl", hash = "sha256:922820b53db7a7257ffbda3f597266d435245903d80737e34f8a45ff3e3230d8", size = 167321 },
 55 | ]
 56 | 
 57 | [[package]]
 58 | name = "cffi"
 59 | version = "1.17.1"
 60 | source = { registry = "https://pypi.org/simple" }
 61 | dependencies = [
 62 |     { name = "pycparser" },
 63 | ]
 64 | sdist = { url = "https://files.pythonhosted.org/packages/fc/97/c783634659c2920c3fc70419e3af40972dbaf758daa229a7d6ea6135c90d/cffi-1.17.1.tar.gz", hash = "sha256:1c39c6016c32bc48dd54561950ebd6836e1670f2ae46128f67cf49e789c52824", size = 516621 }
 65 | wheels = [
 66 |     { url = "https://files.pythonhosted.org/packages/f8/fe/4d41c2f200c4a457933dbd98d3cf4e911870877bd94d9656cc0fcb390681/cffi-1.17.1-cp310-cp310-win32.whl", hash = "sha256:c9c3d058ebabb74db66e431095118094d06abf53284d9c81f27300d0e0d8bc7c", size = 171804 },
 67 |     { url = "https://files.pythonhosted.org/packages/d1/b6/0b0f5ab93b0df4acc49cae758c81fe4e5ef26c3ae2e10cc69249dfd8b3ab/cffi-1.17.1-cp310-cp310-win_amd64.whl", hash = "sha256:0f048dcf80db46f0098ccac01132761580d28e28bc0f78ae0d58048063317e15", size = 181299 },
 68 |     { url = "https://files.pythonhosted.org/packages/34/33/e1b8a1ba29025adbdcda5fb3a36f94c03d771c1b7b12f726ff7fef2ebe36/cffi-1.17.1-cp311-cp311-win32.whl", hash = "sha256:85a950a4ac9c359340d5963966e3e0a94a676bd6245a4b55bc43949eee26a655", size = 171727 },
 69 |     { url = "https://files.pythonhosted.org/packages/3d/97/50228be003bb2802627d28ec0627837ac0bf35c90cf769812056f235b2d1/cffi-1.17.1-cp311-cp311-win_amd64.whl", hash = "sha256:caaf0640ef5f5517f49bc275eca1406b0ffa6aa184892812030f04c2abf589a0", size = 181400 },
 70 |     { url = "https://files.pythonhosted.org/packages/86/c5/28b2d6f799ec0bdecf44dced2ec5ed43e0eb63097b0f58c293583b406582/cffi-1.17.1-cp312-cp312-win32.whl", hash = "sha256:a08d7e755f8ed21095a310a693525137cfe756ce62d066e53f502a83dc550f65", size = 172448 },
 71 |     { url = "https://files.pythonhosted.org/packages/50/b9/db34c4755a7bd1cb2d1603ac3863f22bcecbd1ba29e5ee841a4bc510b294/cffi-1.17.1-cp312-cp312-win_amd64.whl", hash = "sha256:51392eae71afec0d0c8fb1a53b204dbb3bcabcb3c9b807eedf3e1e6ccf2de903", size = 181976 },
 72 |     { url = "https://files.pythonhosted.org/packages/bf/ee/f94057fa6426481d663b88637a9a10e859e492c73d0384514a17d78ee205/cffi-1.17.1-cp313-cp313-win32.whl", hash = "sha256:e03eab0a8677fa80d646b5ddece1cbeaf556c313dcfac435ba11f107ba117b5d", size = 172475 },
 73 |     { url = "https://files.pythonhosted.org/packages/7c/fc/6a8cb64e5f0324877d503c854da15d76c1e50eb722e320b15345c4d0c6de/cffi-1.17.1-cp313-cp313-win_amd64.whl", hash = "sha256:f6a16c31041f09ead72d69f583767292f750d24913dadacf5756b966aacb3f1a", size = 182009 },
 74 | ]
 75 | 
 76 | [[package]]
 77 | name = "click"
 78 | version = "8.1.0"
 79 | source = { registry = "https://pypi.org/simple" }
 80 | dependencies = [
 81 |     { name = "colorama", marker = "platform_system == 'Windows'" },
 82 | ]
 83 | sdist = { url = "https://files.pythonhosted.org/packages/45/2b/7ebad1e59a99207d417c0784f7fb67893465eef84b5b47c788324f1b4095/click-8.1.0.tar.gz", hash = "sha256:977c213473c7665d3aa092b41ff12063227751c41d7b17165013e10069cc5cd2", size = 329986 }
 84 | wheels = [
 85 |     { url = "https://files.pythonhosted.org/packages/86/3e/3a523bdd24510288b1b850428e01172116a29268378b1da9a8d0b894a115/click-8.1.0-py3-none-any.whl", hash = "sha256:19a4baa64da924c5e0cd889aba8e947f280309f1a2ce0947a3e3a7bcb7cc72d6", size = 96400 },
 86 | ]
 87 | 
 88 | [[package]]
 89 | name = "colorama"
 90 | version = "0.4.6"
 91 | source = { registry = "https://pypi.org/simple" }
 92 | sdist = { url = "https://files.pythonhosted.org/packages/d8/53/6f443c9a4a8358a93a6792e2acffb9d9d5cb0a5cfd8802644b7b1c9a02e4/colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44", size = 27697 }
 93 | wheels = [
 94 |     { url = "https://files.pythonhosted.org/packages/d1/d6/3965ed04c63042e047cb6a3e6ed1a63a35087b6a609aa3a15ed8ac56c221/colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6", size = 25335 },
 95 | ]
 96 | 
 97 | [[package]]
 98 | name = "exceptiongroup"
 99 | version = "1.2.2"
100 | source = { registry = "https://pypi.org/simple" }
101 | sdist = { url = "https://files.pythonhosted.org/packages/09/35/2495c4ac46b980e4ca1f6ad6db102322ef3ad2410b79fdde159a4b0f3b92/exceptiongroup-1.2.2.tar.gz", hash = "sha256:47c2edf7c6738fafb49fd34290706d1a1a2f4d1c6df275526b62cbb4aa5393cc", size = 28883 }
102 | wheels = [
103 |     { url = "https://files.pythonhosted.org/packages/02/cc/b7e31358aac6ed1ef2bb790a9746ac2c69bcb3c8588b41616914eb106eaf/exceptiongroup-1.2.2-py3-none-any.whl", hash = "sha256:3111b9d131c238bec2f8f516e123e14ba243563fb135d3fe885990585aa7795b", size = 16453 },
104 | ]
105 | 
106 | [[package]]
107 | name = "h11"
108 | version = "0.14.0"
109 | source = { registry = "https://pypi.org/simple" }
110 | sdist = { url = "https://files.pythonhosted.org/packages/f5/38/3af3d3633a34a3316095b39c8e8fb4853a28a536e55d347bd8d8e9a14b03/h11-0.14.0.tar.gz", hash = "sha256:8f19fbbe99e72420ff35c00b27a34cb9937e902a8b810e2c88300c6f0a3b699d", size = 100418 }
111 | wheels = [
112 |     { url = "https://files.pythonhosted.org/packages/95/04/ff642e65ad6b90db43e668d70ffb6736436c7ce41fcc549f4e9472234127/h11-0.14.0-py3-none-any.whl", hash = "sha256:e3fe4ac4b851c468cc8363d500db52c2ead036020723024a109d37346efaa761", size = 58259 },
113 | ]
114 | 
115 | [[package]]
116 | name = "httpcore"
117 | version = "1.0.7"
118 | source = { registry = "https://pypi.org/simple" }
119 | dependencies = [
120 |     { name = "certifi" },
121 |     { name = "h11" },
122 | ]
123 | sdist = { url = "https://files.pythonhosted.org/packages/6a/41/d7d0a89eb493922c37d343b607bc1b5da7f5be7e383740b4753ad8943e90/httpcore-1.0.7.tar.gz", hash = "sha256:8551cb62a169ec7162ac7be8d4817d561f60e08eaa485234898414bb5a8a0b4c", size = 85196 }
124 | wheels = [
125 |     { url = "https://files.pythonhosted.org/packages/87/f5/72347bc88306acb359581ac4d52f23c0ef445b57157adedb9aee0cd689d2/httpcore-1.0.7-py3-none-any.whl", hash = "sha256:a3fff8f43dc260d5bd363d9f9cf1830fa3a458b332856f34282de498ed420edd", size = 78551 },
126 | ]
127 | 
128 | [[package]]
129 | name = "httpx"
130 | version = "0.27.0"
131 | source = { registry = "https://pypi.org/simple" }
132 | dependencies = [
133 |     { name = "anyio" },
134 |     { name = "certifi" },
135 |     { name = "httpcore" },
136 |     { name = "idna" },
137 |     { name = "sniffio" },
138 | ]
139 | sdist = { url = "https://files.pythonhosted.org/packages/5c/2d/3da5bdf4408b8b2800061c339f240c1802f2e82d55e50bd39c5a881f47f0/httpx-0.27.0.tar.gz", hash = "sha256:a0cb88a46f32dc874e04ee956e4c2764aba2aa228f650b06788ba6bda2962ab5", size = 126413 }
140 | wheels = [
141 |     { url = "https://files.pythonhosted.org/packages/41/7b/ddacf6dcebb42466abd03f368782142baa82e08fc0c1f8eaa05b4bae87d5/httpx-0.27.0-py3-none-any.whl", hash = "sha256:71d5465162c13681bff01ad59b2cc68dd838ea1f10e51574bac27103f00c91a5", size = 75590 },
142 | ]
143 | 
144 | [[package]]
145 | name = "httpx-sse"
146 | version = "0.4.0"
147 | source = { registry = "https://pypi.org/simple" }
148 | sdist = { url = "https://files.pythonhosted.org/packages/4c/60/8f4281fa9bbf3c8034fd54c0e7412e66edbab6bc74c4996bd616f8d0406e/httpx-sse-0.4.0.tar.gz", hash = "sha256:1e81a3a3070ce322add1d3529ed42eb5f70817f45ed6ec915ab753f961139721", size = 12624 }
149 | wheels = [
150 |     { url = "https://files.pythonhosted.org/packages/e1/9b/a181f281f65d776426002f330c31849b86b31fc9d848db62e16f03ff739f/httpx_sse-0.4.0-py3-none-any.whl", hash = "sha256:f329af6eae57eaa2bdfd962b42524764af68075ea87370a2de920af5341e318f", size = 7819 },
151 | ]
152 | 
153 | [[package]]
154 | name = "idna"
155 | version = "3.10"
156 | source = { registry = "https://pypi.org/simple" }
157 | sdist = { url = "https://files.pythonhosted.org/packages/f1/70/7703c29685631f5a7590aa73f1f1d3fa9a380e654b86af429e0934a32f7d/idna-3.10.tar.gz", hash = "sha256:12f65c9b470abda6dc35cf8e63cc574b1c52b11df2c86030af0ac09b01b13ea9", size = 190490 }
158 | wheels = [
159 |     { url = "https://files.pythonhosted.org/packages/76/c6/c88e154df9c4e1a2a66ccf0005a88dfb2650c1dffb6f5ce603dfbd452ce3/idna-3.10-py3-none-any.whl", hash = "sha256:946d195a0d259cbba61165e88e65941f16e9b36ea6ddb97f00452bae8b1287d3", size = 70442 },
160 | ]
161 | 
162 | [[package]]
163 | name = "iniconfig"
164 | version = "2.0.0"
165 | source = { registry = "https://pypi.org/simple" }
166 | sdist = { url = "https://files.pythonhosted.org/packages/d7/4b/cbd8e699e64a6f16ca3a8220661b5f83792b3017d0f79807cb8708d33913/iniconfig-2.0.0.tar.gz", hash = "sha256:2d91e135bf72d31a410b17c16da610a82cb55f6b0477d1a902134b24a455b8b3", size = 4646 }
167 | wheels = [
168 |     { url = "https://files.pythonhosted.org/packages/ef/a6/62565a6e1cf69e10f5727360368e451d4b7f58beeac6173dc9db836a5b46/iniconfig-2.0.0-py3-none-any.whl", hash = "sha256:b6a85871a79d2e3b22d2d1b94ac2824226a63c6b741c88f7ae975f18b6778374", size = 5892 },
169 | ]
170 | 
171 | [[package]]
172 | name = "mcp"
173 | version = "1.1.1.dev0"
174 | source = { editable = "." }
175 | dependencies = [
176 |     { name = "anyio" },
177 |     { name = "httpx" },
178 |     { name = "httpx-sse" },
179 |     { name = "pydantic" },
180 |     { name = "sse-starlette" },
181 |     { name = "starlette" },
182 | ]
183 | 
184 | [package.dev-dependencies]
185 | dev = [
186 |     { name = "pyright" },
187 |     { name = "pytest" },
188 |     { name = "ruff" },
189 |     { name = "trio" },
190 | ]
191 | 
192 | [package.metadata]
193 | requires-dist = [
194 |     { name = "anyio", specifier = ">=4.5" },
195 |     { name = "httpx", specifier = ">=0.27" },
196 |     { name = "httpx-sse", specifier = ">=0.4" },
197 |     { name = "pydantic", specifier = ">=2.7.2" },
198 |     { name = "sse-starlette", specifier = ">=2.0" },
199 |     { name = "starlette", specifier = ">=0.27" },
200 | ]
201 | 
202 | [package.metadata.requires-dev]
203 | dev = [
204 |     { name = "pyright", specifier = ">=1.1.378" },
205 |     { name = "pytest", specifier = ">=8.3.3" },
206 |     { name = "ruff", specifier = ">=0.6.9" },
207 |     { name = "trio", specifier = ">=0.26.2" },
208 | ]
209 | 
210 | [[package]]
211 | name = "mcp-simple-prompt"
212 | version = "0.1.0"
213 | source = { editable = "examples/servers/simple-prompt" }
214 | dependencies = [
215 |     { name = "anyio" },
216 |     { name = "click" },
217 |     { name = "httpx" },
218 |     { name = "mcp" },
219 | ]
220 | 
221 | [package.dev-dependencies]
222 | dev = [
223 |     { name = "pyright" },
224 |     { name = "pytest" },
225 |     { name = "ruff" },
226 | ]
227 | 
228 | [package.metadata]
229 | requires-dist = [
230 |     { name = "anyio", specifier = ">=4.5" },
231 |     { name = "click", specifier = ">=8.1.0" },
232 |     { name = "httpx", specifier = ">=0.27" },
233 |     { name = "mcp", editable = "." },
234 | ]
235 | 
236 | [package.metadata.requires-dev]
237 | dev = [
238 |     { name = "pyright", specifier = ">=1.1.378" },
239 |     { name = "pytest", specifier = ">=8.3.3" },
240 |     { name = "ruff", specifier = ">=0.6.9" },
241 | ]
242 | 
243 | [[package]]
244 | name = "mcp-simple-resource"
245 | version = "0.1.0"
246 | source = { editable = "examples/servers/simple-resource" }
247 | dependencies = [
248 |     { name = "anyio" },
249 |     { name = "click" },
250 |     { name = "httpx" },
251 |     { name = "mcp" },
252 | ]
253 | 
254 | [package.dev-dependencies]
255 | dev = [
256 |     { name = "pyright" },
257 |     { name = "pytest" },
258 |     { name = "ruff" },
259 | ]
260 | 
261 | [package.metadata]
262 | requires-dist = [
263 |     { name = "anyio", specifier = ">=4.5" },
264 |     { name = "click", specifier = ">=8.1.0" },
265 |     { name = "httpx", specifier = ">=0.27" },
266 |     { name = "mcp", editable = "." },
267 | ]
268 | 
269 | [package.metadata.requires-dev]
270 | dev = [
271 |     { name = "pyright", specifier = ">=1.1.378" },
272 |     { name = "pytest", specifier = ">=8.3.3" },
273 |     { name = "ruff", specifier = ">=0.6.9" },
274 | ]
275 | 
276 | [[package]]
277 | name = "mcp-simple-tool"
278 | version = "0.1.0"
279 | source = { editable = "examples/servers/simple-tool" }
280 | dependencies = [
281 |     { name = "anyio" },
282 |     { name = "click" },
283 |     { name = "httpx" },
284 |     { name = "mcp" },
285 | ]
286 | 
287 | [package.dev-dependencies]
288 | dev = [
289 |     { name = "pyright" },
290 |     { name = "pytest" },
291 |     { name = "ruff" },
292 | ]
293 | 
294 | [package.metadata]
295 | requires-dist = [
296 |     { name = "anyio", specifier = ">=4.5" },
297 |     { name = "click", specifier = ">=8.1.0" },
298 |     { name = "httpx", specifier = ">=0.27" },
299 |     { name = "mcp", editable = "." },
300 | ]
301 | 
302 | [package.metadata.requires-dev]
303 | dev = [
304 |     { name = "pyright", specifier = ">=1.1.378" },
305 |     { name = "pytest", specifier = ">=8.3.3" },
306 |     { name = "ruff", specifier = ">=0.6.9" },
307 | ]
308 | 
309 | [[package]]
310 | name = "nodeenv"
311 | version = "1.9.1"
312 | source = { registry = "https://pypi.org/simple" }
313 | sdist = { url = "https://files.pythonhosted.org/packages/43/16/fc88b08840de0e0a72a2f9d8c6bae36be573e475a6326ae854bcc549fc45/nodeenv-1.9.1.tar.gz", hash = "sha256:6ec12890a2dab7946721edbfbcd91f3319c6ccc9aec47be7c7e6b7011ee6645f", size = 47437 }
314 | wheels = [
315 |     { url = "https://files.pythonhosted.org/packages/d2/1d/1b658dbd2b9fa9c4c9f32accbfc0205d532c8c6194dc0f2a4c0428e7128a/nodeenv-1.9.1-py2.py3-none-any.whl", hash = "sha256:ba11c9782d29c27c70ffbdda2d7415098754709be8a7056d79a737cd901155c9", size = 22314 },
316 | ]
317 | 
318 | [[package]]
319 | name = "outcome"
320 | version = "1.3.0.post0"
321 | source = { registry = "https://pypi.org/simple" }
322 | dependencies = [
323 |     { name = "attrs" },
324 | ]
325 | sdist = { url = "https://files.pythonhosted.org/packages/98/df/77698abfac98571e65ffeb0c1fba8ffd692ab8458d617a0eed7d9a8d38f2/outcome-1.3.0.post0.tar.gz", hash = "sha256:9dcf02e65f2971b80047b377468e72a268e15c0af3cf1238e6ff14f7f91143b8", size = 21060 }
326 | wheels = [
327 |     { url = "https://files.pythonhosted.org/packages/55/8b/5ab7257531a5d830fc8000c476e63c935488d74609b50f9384a643ec0a62/outcome-1.3.0.post0-py2.py3-none-any.whl", hash = "sha256:e771c5ce06d1415e356078d3bdd68523f284b4ce5419828922b6871e65eda82b", size = 10692 },
328 | ]
329 | 
330 | [[package]]
331 | name = "packaging"
332 | version = "24.2"
333 | source = { registry = "https://pypi.org/simple" }
334 | sdist = { url = "https://files.pythonhosted.org/packages/d0/63/68dbb6eb2de9cb10ee4c9c14a0148804425e13c4fb20d61cce69f53106da/packaging-24.2.tar.gz", hash = "sha256:c228a6dc5e932d346bc5739379109d49e8853dd8223571c7c5b55260edc0b97f", size = 163950 }
335 | wheels = [
336 |     { url = "https://files.pythonhosted.org/packages/88/ef/eb23f262cca3c0c4eb7ab1933c3b1f03d021f2c48f54763065b6f0e321be/packaging-24.2-py3-none-any.whl", hash = "sha256:09abb1bccd265c01f4a3aa3f7a7db064b36514d2cba19a2f694fe6150451a759", size = 65451 },
337 | ]
338 | 
339 | [[package]]
340 | name = "pluggy"
341 | version = "1.5.0"
342 | source = { registry = "https://pypi.org/simple" }
343 | sdist = { url = "https://files.pythonhosted.org/packages/96/2d/02d4312c973c6050a18b314a5ad0b3210edb65a906f868e31c111dede4a6/pluggy-1.5.0.tar.gz", hash = "sha256:2cffa88e94fdc978c4c574f15f9e59b7f4201d439195c3715ca9e2486f1d0cf1", size = 67955 }
344 | wheels = [
345 |     { url = "https://files.pythonhosted.org/packages/88/5f/e351af9a41f866ac3f1fac4ca0613908d9a41741cfcf2228f4ad853b697d/pluggy-1.5.0-py3-none-any.whl", hash = "sha256:44e1ad92c8ca002de6377e165f3e0f1be63266ab4d554740532335b9d75ea669", size = 20556 },
346 | ]
347 | 
348 | [[package]]
349 | name = "pycparser"
350 | version = "2.22"
351 | source = { registry = "https://pypi.org/simple" }
352 | sdist = { url = "https://files.pythonhosted.org/packages/1d/b2/31537cf4b1ca988837256c910a668b553fceb8f069bedc4b1c826024b52c/pycparser-2.22.tar.gz", hash = "sha256:491c8be9c040f5390f5bf44a5b07752bd07f56edf992381b05c701439eec10f6", size = 172736 }
353 | wheels = [
354 |     { url = "https://files.pythonhosted.org/packages/13/a3/a812df4e2dd5696d1f351d58b8fe16a405b234ad2886a0dab9183fb78109/pycparser-2.22-py3-none-any.whl", hash = "sha256:c3702b6d3dd8c7abc1afa565d7e63d53a1d0bd86cdc24edd75470f4de499cfcc", size = 117552 },
355 | ]
356 | 
357 | [[package]]
358 | name = "pydantic"
359 | version = "2.7.2"
360 | source = { registry = "https://pypi.org/simple" }
361 | dependencies = [
362 |     { name = "annotated-types" },
363 |     { name = "pydantic-core" },
364 |     { name = "typing-extensions" },
365 | ]
366 | sdist = { url = "https://files.pythonhosted.org/packages/e9/ed/b7a827705eb2490ffb6752a0302e58611ea743d7140e7dafaedee2afc953/pydantic-2.7.2.tar.gz", hash = "sha256:71b2945998f9c9b7919a45bde9a50397b289937d215ae141c1d0903ba7149fd7", size = 714293 }
367 | wheels = [
368 |     { url = "https://files.pythonhosted.org/packages/6f/b9/ec44b1394957d5aa8d3a7c33f8304cd7670d10a43a286db56cec086346be/pydantic-2.7.2-py3-none-any.whl", hash = "sha256:834ab954175f94e6e68258537dc49402c4a5e9d0409b9f1b86b7e934a8372de7", size = 409545 },
369 | ]
370 | 
371 | [[package]]
372 | name = "pydantic-core"
373 | version = "2.18.3"
374 | source = { registry = "https://pypi.org/simple" }
375 | dependencies = [
376 |     { name = "typing-extensions" },
377 | ]
378 | sdist = { url = "https://files.pythonhosted.org/packages/38/75/6da10bfa9a317884a7b4bf0c42297aca72391ad69eb51b974bded53fddc0/pydantic_core-2.18.3.tar.gz", hash = "sha256:432e999088d85c8f36b9a3f769a8e2b57aabd817bbb729a90d1fe7f18f6f1f39", size = 384545 }
379 | wheels = [
380 |     { url = "https://files.pythonhosted.org/packages/82/ff/61c330412137b46a55b2269d0a49fd8b90e29fb57b72760b8e09b49db896/pydantic_core-2.18.3-cp310-cp310-macosx_10_12_x86_64.whl", hash = "sha256:744697428fcdec6be5670460b578161d1ffe34743a5c15656be7ea82b008197c", size = 1832602 },
381 |     { url = "https://files.pythonhosted.org/packages/7d/3d/1640253d1da28910b02b00bf6af4a80f1de27f561879128f76bbacb8436d/pydantic_core-2.18.3-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:37b40c05ced1ba4218b14986fe6f283d22e1ae2ff4c8e28881a70fb81fbfcda7", size = 1752322 },
382 |     { url = "https://files.pythonhosted.org/packages/97/1f/0d18bac0a38f8f407c219d1b558e959efc94297c1f23810dba64a64624cc/pydantic_core-2.18.3-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:544a9a75622357076efb6b311983ff190fbfb3c12fc3a853122b34d3d358126c", size = 1776174 },
383 |     { url = "https://files.pythonhosted.org/packages/94/ea/ce0d90ff9a623e0fe8916bfd89b5fa49b2193493965e7a7787459c1ccb7c/pydantic_core-2.18.3-cp310-cp310-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:e2e253af04ceaebde8eb201eb3f3e3e7e390f2d275a88300d6a1959d710539e2", size = 1767064 },
384 |     { url = "https://files.pythonhosted.org/packages/29/23/13b0fb2419b6d21e5f0b7292e6c09720e913b068a441df32cf8cbbc16133/pydantic_core-2.18.3-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:855ec66589c68aa367d989da5c4755bb74ee92ccad4fdb6af942c3612c067e34", size = 1964644 },
385 |     { url = "https://files.pythonhosted.org/packages/97/44/22afcd3b8650e157c87d20b73f8a27c25f4f0f240bdc9eb5248bbcdc6f30/pydantic_core-2.18.3-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:3d3e42bb54e7e9d72c13ce112e02eb1b3b55681ee948d748842171201a03a98a", size = 2815869 },
386 |     { url = "https://files.pythonhosted.org/packages/a0/27/aeade6d7b2f2bcc8fc835bdf6aa705f6f34508da380f170e13cd37477dd4/pydantic_core-2.18.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:c6ac9ffccc9d2e69d9fba841441d4259cb668ac180e51b30d3632cd7abca2b9b", size = 2028872 },
387 |     { url = "https://files.pythonhosted.org/packages/b1/0e/a8a462fade9a9a533a9379da246e3fe7d9383c5203b6f6862a54284ea744/pydantic_core-2.18.3-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:c56eca1686539fa0c9bda992e7bd6a37583f20083c37590413381acfc5f192d6", size = 1891477 },
388 |     { url = "https://files.pythonhosted.org/packages/35/1b/63c24026c6207b5aa5cd749af319891b5ac3139e2b5dd789bf4a9e95085e/pydantic_core-2.18.3-cp310-cp310-musllinux_1_1_aarch64.whl", hash = "sha256:17954d784bf8abfc0ec2a633108207ebc4fa2df1a0e4c0c3ccbaa9bb01d2c426", size = 1996291 },
389 |     { url = "https://files.pythonhosted.org/packages/79/34/05139583ecef8b5a0f5be8105b6b001016e054bcf63ac96a03790c4a790d/pydantic_core-2.18.3-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:98ed737567d8f2ecd54f7c8d4f8572ca7c7921ede93a2e52939416170d357812", size = 2097593 },
390 |     { url = "https://files.pythonhosted.org/packages/a3/e3/0b53c3b8e71be2db70eb7bfb6811bd6d093aa41fdb1ccc9f7ea18b40287b/pydantic_core-2.18.3-cp310-none-win32.whl", hash = "sha256:9f9e04afebd3ed8c15d67a564ed0a34b54e52136c6d40d14c5547b238390e779", size = 1700454 },
391 |     { url = "https://files.pythonhosted.org/packages/e2/67/85ee8a54220139159b14088dd40f4d43e60822f8d64bb2a5b9b04d673bd2/pydantic_core-2.18.3-cp310-none-win_amd64.whl", hash = "sha256:45e4ffbae34f7ae30d0047697e724e534a7ec0a82ef9994b7913a412c21462a0", size = 1889156 },
392 |     { url = "https://files.pythonhosted.org/packages/4a/cf/2847167bab3e7676ba6f0b49963ba04112b1e4281d8c70e302c2fd29e08c/pydantic_core-2.18.3-cp311-cp311-macosx_10_12_x86_64.whl", hash = "sha256:b9ebe8231726c49518b16b237b9fe0d7d361dd221302af511a83d4ada01183ab", size = 1831516 },
393 |     { url = "https://files.pythonhosted.org/packages/0c/84/a14457b3cb1ec1f5d1567395abe11ab420dd76733bc79dd0124a874e9eac/pydantic_core-2.18.3-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:b8e20e15d18bf7dbb453be78a2d858f946f5cdf06c5072453dace00ab652e2b2", size = 1751781 },
394 |     { url = "https://files.pythonhosted.org/packages/9a/a5/5c1d98cdba8e6b2fda1975dcdb59cd608257eee69637deca22389ca16a54/pydantic_core-2.18.3-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c0d9ff283cd3459fa0bf9b0256a2b6f01ac1ff9ffb034e24457b9035f75587cb", size = 1775332 },
395 |     { url = "https://files.pythonhosted.org/packages/f7/27/83d6903b1eb5ac5db67acf7be1b397c962acba1bbb27bc4fa6af4b4e82bb/pydantic_core-2.18.3-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:2f7ef5f0ebb77ba24c9970da18b771711edc5feaf00c10b18461e0f5f5949231", size = 1766532 },
396 |     { url = "https://files.pythonhosted.org/packages/41/83/db99c69d1f3bf71b0771d7233ac65722ba24ebc39b76b4f168da735726e0/pydantic_core-2.18.3-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:73038d66614d2e5cde30435b5afdced2b473b4c77d4ca3a8624dd3e41a9c19be", size = 1964053 },
397 |     { url = "https://files.pythonhosted.org/packages/49/78/daf71cbf3b3bc1605bc750b37c5e70dff985b676fd66ac7427b8fb730dc7/pydantic_core-2.18.3-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:6afd5c867a74c4d314c557b5ea9520183fadfbd1df4c2d6e09fd0d990ce412cd", size = 2814359 },
398 |     { url = "https://files.pythonhosted.org/packages/08/6b/391098a7f0863b5e54c60244c069acfca969af56af4eb7cf52e08b009560/pydantic_core-2.18.3-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:bd7df92f28d351bb9f12470f4c533cf03d1b52ec5a6e5c58c65b183055a60106", size = 2028398 },
399 |     { url = "https://files.pythonhosted.org/packages/41/f5/cf4a616568dddd85c71bf8b4bdc492c41c1af6eb9b0fc87e8835fd63447c/pydantic_core-2.18.3-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:80aea0ffeb1049336043d07799eace1c9602519fb3192916ff525b0287b2b1e4", size = 1891053 },
400 |     { url = "https://files.pythonhosted.org/packages/44/2e/ebdc3f4deb3e3bbf14f0da00394dd07074cfb2ea1431024ed0fc64be3e9c/pydantic_core-2.18.3-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:aaee40f25bba38132e655ffa3d1998a6d576ba7cf81deff8bfa189fb43fd2bbe", size = 1995808 },
401 |     { url = "https://files.pythonhosted.org/packages/85/96/6f37b40651b3e43a3c9d0cf8419b333d1f0edc20f70171a9aa52a44d45c8/pydantic_core-2.18.3-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:9128089da8f4fe73f7a91973895ebf2502539d627891a14034e45fb9e707e26d", size = 2096891 },
402 |     { url = "https://files.pythonhosted.org/packages/9d/9f/d3d655c8e09eb87a5eecbb5d442205c56c9dd9acd49670386c29c430f5ea/pydantic_core-2.18.3-cp311-none-win32.whl", hash = "sha256:fec02527e1e03257aa25b1a4dcbe697b40a22f1229f5d026503e8b7ff6d2eda7", size = 1699771 },
403 |     { url = "https://files.pythonhosted.org/packages/d2/c7/e01cb2017c4b7b274258694f73e8bbbb0988a28b49802e569d1d9bfd51cb/pydantic_core-2.18.3-cp311-none-win_amd64.whl", hash = "sha256:58ff8631dbab6c7c982e6425da8347108449321f61fe427c52ddfadd66642af7", size = 1888426 },
404 |     { url = "https://files.pythonhosted.org/packages/fc/90/30f4755a09691f4efebc93e86c98e696e8a109db5a5b36f1d0d94311eac1/pydantic_core-2.18.3-cp311-none-win_arm64.whl", hash = "sha256:3fc1c7f67f34c6c2ef9c213e0f2a351797cda98249d9ca56a70ce4ebcaba45f4", size = 1762547 },
405 |     { url = "https://files.pythonhosted.org/packages/77/72/3ce28b58f3d9c9a8bb59984d810be3eabba4455e92de806a4edacd4e5c0b/pydantic_core-2.18.3-cp312-cp312-macosx_10_12_x86_64.whl", hash = "sha256:f0928cde2ae416a2d1ebe6dee324709c6f73e93494d8c7aea92df99aab1fc40f", size = 1826479 },
406 |     { url = "https://files.pythonhosted.org/packages/94/bc/e5d1938f36cad75525e923ecfef6f544970d4f14800716728ea5555fc574/pydantic_core-2.18.3-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:0bee9bb305a562f8b9271855afb6ce00223f545de3d68560b3c1649c7c5295e9", size = 1750007 },
407 |     { url = "https://files.pythonhosted.org/packages/20/a8/4c6eb74f4b421e9ea62e2bea42683b58ed2d43376895ecc5c376f3cc1630/pydantic_core-2.18.3-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:e862823be114387257dacbfa7d78547165a85d7add33b446ca4f4fae92c7ff5c", size = 1771054 },
408 |     { url = "https://files.pythonhosted.org/packages/f6/0a/d5a1765b5000f56ee3a9659658aed4f978bb85b45bb01c0f921f2a70b511/pydantic_core-2.18.3-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:6a36f78674cbddc165abab0df961b5f96b14461d05feec5e1f78da58808b97e7", size = 1752825 },
409 |     { url = "https://files.pythonhosted.org/packages/0c/20/2e7da2f5cbc6f1849c6bad4ea04e8e763512f4af6250972c35d354b59ab1/pydantic_core-2.18.3-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:ba905d184f62e7ddbb7a5a751d8a5c805463511c7b08d1aca4a3e8c11f2e5048", size = 1962656 },
410 |     { url = "https://files.pythonhosted.org/packages/7e/bb/f01be2f91439f155f8b522259ef92099383d3d6e8df559caa26b8d21dd43/pydantic_core-2.18.3-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:7fdd362f6a586e681ff86550b2379e532fee63c52def1c666887956748eaa326", size = 2738939 },
411 |     { url = "https://files.pythonhosted.org/packages/c2/9f/e2f17d24aee5406a8e8e57784fa737abde9ac538d18028b523268796bcce/pydantic_core-2.18.3-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:24b214b7ee3bd3b865e963dbed0f8bc5375f49449d70e8d407b567af3222aae4", size = 2066345 },
412 |     { url = "https://files.pythonhosted.org/packages/59/c2/5597c61f62cef54cd3f183db5980bf7b3ee7aeb9bd9ab3458d275af33bd7/pydantic_core-2.18.3-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:691018785779766127f531674fa82bb368df5b36b461622b12e176c18e119022", size = 1886795 },
413 |     { url = "https://files.pythonhosted.org/packages/da/b6/2e0a0a51b8fe047d985a7ee1b328d8d8fbef5be54c4870bbe21d2cb846de/pydantic_core-2.18.3-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:60e4c625e6f7155d7d0dcac151edf5858102bc61bf959d04469ca6ee4e8381bd", size = 1991654 },
414 |     { url = "https://files.pythonhosted.org/packages/9c/ef/ade132a1d5a6f5bceee347b06a3853d63730d508c6e91dbd83ec44c4361e/pydantic_core-2.18.3-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:a4e651e47d981c1b701dcc74ab8fec5a60a5b004650416b4abbef13db23bc7be", size = 2098061 },
415 |     { url = "https://files.pythonhosted.org/packages/1d/4b/a925d2ada3d8a554a362c29f1b0f60cb82db7e791e43e91a6f6bc093dacd/pydantic_core-2.18.3-cp312-none-win32.whl", hash = "sha256:ffecbb5edb7f5ffae13599aec33b735e9e4c7676ca1633c60f2c606beb17efc5", size = 1704763 },
416 |     { url = "https://files.pythonhosted.org/packages/e3/5c/477dac00c0d6d34921fec2507ae6aea2cd7c84072eab1dca5bcbbf86c4a2/pydantic_core-2.18.3-cp312-none-win_amd64.whl", hash = "sha256:2c8333f6e934733483c7eddffdb094c143b9463d2af7e6bd85ebcb2d4a1b82c6", size = 1884445 },
417 |     { url = "https://files.pythonhosted.org/packages/4d/f4/285df83eb0c4a8c710bf002b342a114fcd9e388946a0a35dc06f687f865d/pydantic_core-2.18.3-cp312-none-win_arm64.whl", hash = "sha256:7a20dded653e516a4655f4c98e97ccafb13753987434fe7cf044aa25f5b7d417", size = 1763753 },
418 |     { url = "https://files.pythonhosted.org/packages/7f/6b/7bb6e75d4cb9aacca9683cb491b194e94146c6a304de5857a13e3dc0e094/pydantic_core-2.18.3-pp310-pypy310_pp73-macosx_10_12_x86_64.whl", hash = "sha256:77319771a026f7c7d29c6ebc623de889e9563b7087911b46fd06c044a12aa5e9", size = 1830389 },
419 |     { url = "https://files.pythonhosted.org/packages/a5/e6/a3775ca64d41a9cfd2ff57f1322e5e9cec12809f87c58f09d3c4d468d6db/pydantic_core-2.18.3-pp310-pypy310_pp73-macosx_11_0_arm64.whl", hash = "sha256:df11fa992e9f576473038510d66dd305bcd51d7dd508c163a8c8fe148454e059", size = 1711345 },
420 |     { url = "https://files.pythonhosted.org/packages/30/64/b6a46b84f1237511aaeb8e73b3b357bdb34f63c958b92a483c7abdfe6b73/pydantic_core-2.18.3-pp310-pypy310_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:d531076bdfb65af593326ffd567e6ab3da145020dafb9187a1d131064a55f97c", size = 1774898 },
421 |     { url = "https://files.pythonhosted.org/packages/ac/ca/0fd2e3849cd6b87b08fa9676dec86bf33c6c9fbc80af2247b0120dbfae80/pydantic_core-2.18.3-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:d33ce258e4e6e6038f2b9e8b8a631d17d017567db43483314993b3ca345dcbbb", size = 1923112 },
422 |     { url = "https://files.pythonhosted.org/packages/32/92/eab2738a19fea14f55314eca5e31d85e0680daa1d439d9a4485ba808faf2/pydantic_core-2.18.3-pp310-pypy310_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:1f9cd7f5635b719939019be9bda47ecb56e165e51dd26c9a217a433e3d0d59a9", size = 1888546 },
423 |     { url = "https://files.pythonhosted.org/packages/fe/85/32c6733055194d624b1a03c1ae6fee4121c1ecac99d87a63a9911eac7d65/pydantic_core-2.18.3-pp310-pypy310_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:cd4a032bb65cc132cae1fe3e52877daecc2097965cd3914e44fbd12b00dae7c5", size = 1994693 },
424 |     { url = "https://files.pythonhosted.org/packages/50/67/ff5701b8f54842f9485d2b27455a4911d99b662ceb44ca81e5e26c9421a9/pydantic_core-2.18.3-pp310-pypy310_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:82f2718430098bcdf60402136c845e4126a189959d103900ebabb6774a5d9fdb", size = 2094391 },
425 |     { url = "https://files.pythonhosted.org/packages/af/d1/1c18f8e215930665e65597dd677937595355057f631bf4b9110aa6f88f79/pydantic_core-2.18.3-pp310-pypy310_pp73-win_amd64.whl", hash = "sha256:c0037a92cf0c580ed14e10953cdd26528e8796307bb8bb312dc65f71547df04d", size = 1898163 },
426 | ]
427 | 
428 | [[package]]
429 | name = "pyright"
430 | version = "1.1.378"
431 | source = { registry = "https://pypi.org/simple" }
432 | dependencies = [
433 |     { name = "nodeenv" },
434 | ]
435 | sdist = { url = "https://files.pythonhosted.org/packages/3d/f0/e8aa5555410d88f898bef04da2102b0a9bf144658c98d34872e91621ced2/pyright-1.1.378.tar.gz", hash = "sha256:78a043be2876d12d0af101d667e92c7734f3ebb9db71dccc2c220e7e7eb89ca2", size = 17486 }
436 | wheels = [
437 |     { url = "https://files.pythonhosted.org/packages/38/c6/f0d4bc20c13b20cecfbf13c699477c825e45767f1dc5068137323f86e495/pyright-1.1.378-py3-none-any.whl", hash = "sha256:8853776138b01bc284da07ac481235be7cc89d3176b073d2dba73636cb95be79", size = 18222 },
438 | ]
439 | 
440 | [[package]]
441 | name = "pytest"
442 | version = "8.3.3"
443 | source = { registry = "https://pypi.org/simple" }
444 | dependencies = [
445 |     { name = "colorama", marker = "sys_platform == 'win32'" },
446 |     { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
447 |     { name = "iniconfig" },
448 |     { name = "packaging" },
449 |     { name = "pluggy" },
450 |     { name = "tomli", marker = "python_full_version < '3.11'" },
451 | ]
452 | sdist = { url = "https://files.pythonhosted.org/packages/8b/6c/62bbd536103af674e227c41a8f3dcd022d591f6eed5facb5a0f31ee33bbc/pytest-8.3.3.tar.gz", hash = "sha256:70b98107bd648308a7952b06e6ca9a50bc660be218d53c257cc1fc94fda10181", size = 1442487 }
453 | wheels = [
454 |     { url = "https://files.pythonhosted.org/packages/6b/77/7440a06a8ead44c7757a64362dd22df5760f9b12dc5f11b6188cd2fc27a0/pytest-8.3.3-py3-none-any.whl", hash = "sha256:a6853c7375b2663155079443d2e45de913a911a11d669df02a50814944db57b2", size = 342341 },
455 | ]
456 | 
457 | [[package]]
458 | name = "ruff"
459 | version = "0.6.9"
460 | source = { registry = "https://pypi.org/simple" }
461 | sdist = { url = "https://files.pythonhosted.org/packages/26/0d/6148a48dab5662ca1d5a93b7c0d13c03abd3cc7e2f35db08410e47cef15d/ruff-0.6.9.tar.gz", hash = "sha256:b076ef717a8e5bc819514ee1d602bbdca5b4420ae13a9cf61a0c0a4f53a2baa2", size = 3095355 }
462 | wheels = [
463 |     { url = "https://files.pythonhosted.org/packages/6e/8f/f7a0a0ef1818662efb32ed6df16078c95da7a0a3248d64c2410c1e27799f/ruff-0.6.9-py3-none-linux_armv6l.whl", hash = "sha256:064df58d84ccc0ac0fcd63bc3090b251d90e2a372558c0f057c3f75ed73e1ccd", size = 10440526 },
464 |     { url = "https://files.pythonhosted.org/packages/8b/69/b179a5faf936a9e2ab45bb412a668e4661eded964ccfa19d533f29463ef6/ruff-0.6.9-py3-none-macosx_10_12_x86_64.whl", hash = "sha256:140d4b5c9f5fc7a7b074908a78ab8d384dd7f6510402267bc76c37195c02a7ec", size = 10034612 },
465 |     { url = "https://files.pythonhosted.org/packages/c7/ef/fd1b4be979c579d191eeac37b5cfc0ec906de72c8bcd8595e2c81bb700c1/ruff-0.6.9-py3-none-macosx_11_0_arm64.whl", hash = "sha256:53fd8ca5e82bdee8da7f506d7b03a261f24cd43d090ea9db9a1dc59d9313914c", size = 9706197 },
466 |     { url = "https://files.pythonhosted.org/packages/29/61/b376d775deb5851cb48d893c568b511a6d3625ef2c129ad5698b64fb523c/ruff-0.6.9-py3-none-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:645d7d8761f915e48a00d4ecc3686969761df69fb561dd914a773c1a8266e14e", size = 10751855 },
467 |     { url = "https://files.pythonhosted.org/packages/13/d7/def9e5f446d75b9a9c19b24231a3a658c075d79163b08582e56fa5dcfa38/ruff-0.6.9-py3-none-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:eae02b700763e3847595b9d2891488989cac00214da7f845f4bcf2989007d577", size = 10200889 },
468 |     { url = "https://files.pythonhosted.org/packages/6c/d6/7f34160818bcb6e84ce293a5966cba368d9112ff0289b273fbb689046047/ruff-0.6.9-py3-none-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:7d5ccc9e58112441de8ad4b29dcb7a86dc25c5f770e3c06a9d57e0e5eba48829", size = 11038678 },
469 |     { url = "https://files.pythonhosted.org/packages/13/34/a40ff8ae62fb1b26fb8e6fa7e64bc0e0a834b47317880de22edd6bfb54fb/ruff-0.6.9-py3-none-manylinux_2_17_ppc64.manylinux2014_ppc64.whl", hash = "sha256:417b81aa1c9b60b2f8edc463c58363075412866ae4e2b9ab0f690dc1e87ac1b5", size = 11808682 },
470 |     { url = "https://files.pythonhosted.org/packages/2e/6d/25a4386ae4009fc798bd10ba48c942d1b0b3e459b5403028f1214b6dd161/ruff-0.6.9-py3-none-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:3c866b631f5fbce896a74a6e4383407ba7507b815ccc52bcedabb6810fdb3ef7", size = 11330446 },
471 |     { url = "https://files.pythonhosted.org/packages/f7/f6/bdf891a9200d692c94ebcd06ae5a2fa5894e522f2c66c2a12dd5d8cb2654/ruff-0.6.9-py3-none-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:7b118afbb3202f5911486ad52da86d1d52305b59e7ef2031cea3425142b97d6f", size = 12483048 },
472 |     { url = "https://files.pythonhosted.org/packages/a7/86/96f4252f41840e325b3fa6c48297e661abb9f564bd7dcc0572398c8daa42/ruff-0.6.9-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:a67267654edc23c97335586774790cde402fb6bbdb3c2314f1fc087dee320bfa", size = 10936855 },
473 |     { url = "https://files.pythonhosted.org/packages/45/87/801a52d26c8dbf73424238e9908b9ceac430d903c8ef35eab1b44fcfa2bd/ruff-0.6.9-py3-none-musllinux_1_2_aarch64.whl", hash = "sha256:3ef0cc774b00fec123f635ce5c547dac263f6ee9fb9cc83437c5904183b55ceb", size = 10713007 },
474 |     { url = "https://files.pythonhosted.org/packages/be/27/6f7161d90320a389695e32b6ebdbfbedde28ccbf52451e4b723d7ce744ad/ruff-0.6.9-py3-none-musllinux_1_2_armv7l.whl", hash = "sha256:12edd2af0c60fa61ff31cefb90aef4288ac4d372b4962c2864aeea3a1a2460c0", size = 10274594 },
475 |     { url = "https://files.pythonhosted.org/packages/00/52/dc311775e7b5f5b19831563cb1572ecce63e62681bccc609867711fae317/ruff-0.6.9-py3-none-musllinux_1_2_i686.whl", hash = "sha256:55bb01caeaf3a60b2b2bba07308a02fca6ab56233302406ed5245180a05c5625", size = 10608024 },
476 |     { url = "https://files.pythonhosted.org/packages/98/b6/be0a1ddcbac65a30c985cf7224c4fce786ba2c51e7efeb5178fe410ed3cf/ruff-0.6.9-py3-none-musllinux_1_2_x86_64.whl", hash = "sha256:925d26471fa24b0ce5a6cdfab1bb526fb4159952385f386bdcc643813d472039", size = 10982085 },
477 |     { url = "https://files.pythonhosted.org/packages/bb/a4/c84bc13d0b573cf7bb7d17b16d6d29f84267c92d79b2f478d4ce322e8e72/ruff-0.6.9-py3-none-win32.whl", hash = "sha256:eb61ec9bdb2506cffd492e05ac40e5bc6284873aceb605503d8494180d6fc84d", size = 8522088 },
478 |     { url = "https://files.pythonhosted.org/packages/74/be/fc352bd8ca40daae8740b54c1c3e905a7efe470d420a268cd62150248c91/ruff-0.6.9-py3-none-win_amd64.whl", hash = "sha256:785d31851c1ae91f45b3d8fe23b8ae4b5170089021fbb42402d811135f0b7117", size = 9359275 },
479 |     { url = "https://files.pythonhosted.org/packages/3e/14/fd026bc74ded05e2351681545a5f626e78ef831f8edce064d61acd2e6ec7/ruff-0.6.9-py3-none-win_arm64.whl", hash = "sha256:a9641e31476d601f83cd602608739a0840e348bda93fec9f1ee816f8b6798b93", size = 8679879 },
480 | ]
481 | 
482 | [[package]]
483 | name = "sniffio"
484 | version = "1.3.1"
485 | source = { registry = "https://pypi.org/simple" }
486 | sdist = { url = "https://files.pythonhosted.org/packages/a2/87/a6771e1546d97e7e041b6ae58d80074f81b7d5121207425c964ddf5cfdbd/sniffio-1.3.1.tar.gz", hash = "sha256:f4324edc670a0f49750a81b895f35c3adb843cca46f0530f79fc1babb23789dc", size = 20372 }
487 | wheels = [
488 |     { url = "https://files.pythonhosted.org/packages/e9/44/75a9c9421471a6c4805dbf2356f7c181a29c1879239abab1ea2cc8f38b40/sniffio-1.3.1-py3-none-any.whl", hash = "sha256:2f6da418d1f1e0fddd844478f41680e794e6051915791a034ff65e5f100525a2", size = 10235 },
489 | ]
490 | 
491 | [[package]]
492 | name = "sortedcontainers"
493 | version = "2.4.0"
494 | source = { registry = "https://pypi.org/simple" }
495 | sdist = { url = "https://files.pythonhosted.org/packages/e8/c4/ba2f8066cceb6f23394729afe52f3bf7adec04bf9ed2c820b39e19299111/sortedcontainers-2.4.0.tar.gz", hash = "sha256:25caa5a06cc30b6b83d11423433f65d1f9d76c4c6a0c90e3379eaa43b9bfdb88", size = 30594 }
496 | wheels = [
497 |     { url = "https://files.pythonhosted.org/packages/32/46/9cb0e58b2deb7f82b84065f37f3bffeb12413f947f9388e4cac22c4621ce/sortedcontainers-2.4.0-py2.py3-none-any.whl", hash = "sha256:a163dcaede0f1c021485e957a39245190e74249897e2ae4b2aa38595db237ee0", size = 29575 },
498 | ]
499 | 
500 | [[package]]
501 | name = "sse-starlette"
502 | version = "2.0.0"
503 | source = { registry = "https://pypi.org/simple" }
504 | dependencies = [
505 |     { name = "anyio" },
506 |     { name = "starlette" },
507 |     { name = "uvicorn" },
508 | ]
509 | sdist = { url = "https://files.pythonhosted.org/packages/3c/54/9651ca960c0fbb997fb2a69dc01b29b182c643eb42a59b82623f7716054a/sse_starlette-2.0.0.tar.gz", hash = "sha256:0c43cc43aca4884c88c8416b65777c4de874cc4773e6458d3579c0a353dc2fb7", size = 18235 }
510 | wheels = [
511 |     { url = "https://files.pythonhosted.org/packages/50/04/b1569f95ce91fbfe35e5e6b3b11e8373ffe4fa81e998818c8c995a873896/sse_starlette-2.0.0-py3-none-any.whl", hash = "sha256:c4dd134302cb9708d47cae23c365fe0a089aa2a875d2f887ac80f235a9ee5744", size = 9032 },
512 | ]
513 | 
514 | [[package]]
515 | name = "starlette"
516 | version = "0.27.0"
517 | source = { registry = "https://pypi.org/simple" }
518 | dependencies = [
519 |     { name = "anyio" },
520 | ]
521 | sdist = { url = "https://files.pythonhosted.org/packages/06/68/559bed5484e746f1ab2ebbe22312f2c25ec62e4b534916d41a8c21147bf8/starlette-0.27.0.tar.gz", hash = "sha256:6a6b0d042acb8d469a01eba54e9cda6cbd24ac602c4cd016723117d6a7e73b75", size = 51394 }
522 | wheels = [
523 |     { url = "https://files.pythonhosted.org/packages/58/f8/e2cca22387965584a409795913b774235752be4176d276714e15e1a58884/starlette-0.27.0-py3-none-any.whl", hash = "sha256:918416370e846586541235ccd38a474c08b80443ed31c578a418e2209b3eef91", size = 66978 },
524 | ]
525 | 
526 | [[package]]
527 | name = "tomli"
528 | version = "2.2.1"
529 | source = { registry = "https://pypi.org/simple" }
530 | sdist = { url = "https://files.pythonhosted.org/packages/18/87/302344fed471e44a87289cf4967697d07e532f2421fdaf868a303cbae4ff/tomli-2.2.1.tar.gz", hash = "sha256:cd45e1dc79c835ce60f7404ec8119f2eb06d38b1deba146f07ced3bbc44505ff", size = 17175 }
531 | wheels = [
532 |     { url = "https://files.pythonhosted.org/packages/43/ca/75707e6efa2b37c77dadb324ae7d9571cb424e61ea73fad7c56c2d14527f/tomli-2.2.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:678e4fa69e4575eb77d103de3df8a895e1591b48e740211bd1067378c69e8249", size = 131077 },
533 |     { url = "https://files.pythonhosted.org/packages/c7/16/51ae563a8615d472fdbffc43a3f3d46588c264ac4f024f63f01283becfbb/tomli-2.2.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:023aa114dd824ade0100497eb2318602af309e5a55595f76b626d6d9f3b7b0a6", size = 123429 },
534 |     { url = "https://files.pythonhosted.org/packages/f1/dd/4f6cd1e7b160041db83c694abc78e100473c15d54620083dbd5aae7b990e/tomli-2.2.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:ece47d672db52ac607a3d9599a9d48dcb2f2f735c6c2d1f34130085bb12b112a", size = 226067 },
535 |     { url = "https://files.pythonhosted.org/packages/a9/6b/c54ede5dc70d648cc6361eaf429304b02f2871a345bbdd51e993d6cdf550/tomli-2.2.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:6972ca9c9cc9f0acaa56a8ca1ff51e7af152a9f87fb64623e31d5c83700080ee", size = 236030 },
536 |     { url = "https://files.pythonhosted.org/packages/1f/47/999514fa49cfaf7a92c805a86c3c43f4215621855d151b61c602abb38091/tomli-2.2.1-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:c954d2250168d28797dd4e3ac5cf812a406cd5a92674ee4c8f123c889786aa8e", size = 240898 },
537 |     { url = "https://files.pythonhosted.org/packages/73/41/0a01279a7ae09ee1573b423318e7934674ce06eb33f50936655071d81a24/tomli-2.2.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:8dd28b3e155b80f4d54beb40a441d366adcfe740969820caf156c019fb5c7ec4", size = 229894 },
538 |     { url = "https://files.pythonhosted.org/packages/55/18/5d8bc5b0a0362311ce4d18830a5d28943667599a60d20118074ea1b01bb7/tomli-2.2.1-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:e59e304978767a54663af13c07b3d1af22ddee3bb2fb0618ca1593e4f593a106", size = 245319 },
539 |     { url = "https://files.pythonhosted.org/packages/92/a3/7ade0576d17f3cdf5ff44d61390d4b3febb8a9fc2b480c75c47ea048c646/tomli-2.2.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:33580bccab0338d00994d7f16f4c4ec25b776af3ffaac1ed74e0b3fc95e885a8", size = 238273 },
540 |     { url = "https://files.pythonhosted.org/packages/72/6f/fa64ef058ac1446a1e51110c375339b3ec6be245af9d14c87c4a6412dd32/tomli-2.2.1-cp311-cp311-win32.whl", hash = "sha256:465af0e0875402f1d226519c9904f37254b3045fc5084697cefb9bdde1ff99ff", size = 98310 },
541 |     { url = "https://files.pythonhosted.org/packages/6a/1c/4a2dcde4a51b81be3530565e92eda625d94dafb46dbeb15069df4caffc34/tomli-2.2.1-cp311-cp311-win_amd64.whl", hash = "sha256:2d0f2fdd22b02c6d81637a3c95f8cd77f995846af7414c5c4b8d0545afa1bc4b", size = 108309 },
542 |     { url = "https://files.pythonhosted.org/packages/52/e1/f8af4c2fcde17500422858155aeb0d7e93477a0d59a98e56cbfe75070fd0/tomli-2.2.1-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:4a8f6e44de52d5e6c657c9fe83b562f5f4256d8ebbfe4ff922c495620a7f6cea", size = 132762 },
543 |     { url = "https://files.pythonhosted.org/packages/03/b8/152c68bb84fc00396b83e7bbddd5ec0bd3dd409db4195e2a9b3e398ad2e3/tomli-2.2.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:8d57ca8095a641b8237d5b079147646153d22552f1c637fd3ba7f4b0b29167a8", size = 123453 },
544 |     { url = "https://files.pythonhosted.org/packages/c8/d6/fc9267af9166f79ac528ff7e8c55c8181ded34eb4b0e93daa767b8841573/tomli-2.2.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:4e340144ad7ae1533cb897d406382b4b6fede8890a03738ff1683af800d54192", size = 233486 },
545 |     { url = "https://files.pythonhosted.org/packages/5c/51/51c3f2884d7bab89af25f678447ea7d297b53b5a3b5730a7cb2ef6069f07/tomli-2.2.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:db2b95f9de79181805df90bedc5a5ab4c165e6ec3fe99f970d0e302f384ad222", size = 242349 },
546 |     { url = "https://files.pythonhosted.org/packages/ab/df/bfa89627d13a5cc22402e441e8a931ef2108403db390ff3345c05253935e/tomli-2.2.1-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:40741994320b232529c802f8bc86da4e1aa9f413db394617b9a256ae0f9a7f77", size = 252159 },
547 |     { url = "https://files.pythonhosted.org/packages/9e/6e/fa2b916dced65763a5168c6ccb91066f7639bdc88b48adda990db10c8c0b/tomli-2.2.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:400e720fe168c0f8521520190686ef8ef033fb19fc493da09779e592861b78c6", size = 237243 },
548 |     { url = "https://files.pythonhosted.org/packages/b4/04/885d3b1f650e1153cbb93a6a9782c58a972b94ea4483ae4ac5cedd5e4a09/tomli-2.2.1-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:02abe224de6ae62c19f090f68da4e27b10af2b93213d36cf44e6e1c5abd19fdd", size = 259645 },
549 |     { url = "https://files.pythonhosted.org/packages/9c/de/6b432d66e986e501586da298e28ebeefd3edc2c780f3ad73d22566034239/tomli-2.2.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:b82ebccc8c8a36f2094e969560a1b836758481f3dc360ce9a3277c65f374285e", size = 244584 },
550 |     { url = "https://files.pythonhosted.org/packages/1c/9a/47c0449b98e6e7d1be6cbac02f93dd79003234ddc4aaab6ba07a9a7482e2/tomli-2.2.1-cp312-cp312-win32.whl", hash = "sha256:889f80ef92701b9dbb224e49ec87c645ce5df3fa2cc548664eb8a25e03127a98", size = 98875 },
551 |     { url = "https://files.pythonhosted.org/packages/ef/60/9b9638f081c6f1261e2688bd487625cd1e660d0a85bd469e91d8db969734/tomli-2.2.1-cp312-cp312-win_amd64.whl", hash = "sha256:7fc04e92e1d624a4a63c76474610238576942d6b8950a2d7f908a340494e67e4", size = 109418 },
552 |     { url = "https://files.pythonhosted.org/packages/04/90/2ee5f2e0362cb8a0b6499dc44f4d7d48f8fff06d28ba46e6f1eaa61a1388/tomli-2.2.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:f4039b9cbc3048b2416cc57ab3bda989a6fcf9b36cf8937f01a6e731b64f80d7", size = 132708 },
553 |     { url = "https://files.pythonhosted.org/packages/c0/ec/46b4108816de6b385141f082ba99e315501ccd0a2ea23db4a100dd3990ea/tomli-2.2.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:286f0ca2ffeeb5b9bd4fcc8d6c330534323ec51b2f52da063b11c502da16f30c", size = 123582 },
554 |     { url = "https://files.pythonhosted.org/packages/a0/bd/b470466d0137b37b68d24556c38a0cc819e8febe392d5b199dcd7f578365/tomli-2.2.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a92ef1a44547e894e2a17d24e7557a5e85a9e1d0048b0b5e7541f76c5032cb13", size = 232543 },
555 |     { url = "https://files.pythonhosted.org/packages/d9/e5/82e80ff3b751373f7cead2815bcbe2d51c895b3c990686741a8e56ec42ab/tomli-2.2.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9316dc65bed1684c9a98ee68759ceaed29d229e985297003e494aa825ebb0281", size = 241691 },
556 |     { url = "https://files.pythonhosted.org/packages/05/7e/2a110bc2713557d6a1bfb06af23dd01e7dde52b6ee7dadc589868f9abfac/tomli-2.2.1-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:e85e99945e688e32d5a35c1ff38ed0b3f41f43fad8df0bdf79f72b2ba7bc5272", size = 251170 },
557 |     { url = "https://files.pythonhosted.org/packages/64/7b/22d713946efe00e0adbcdfd6d1aa119ae03fd0b60ebed51ebb3fa9f5a2e5/tomli-2.2.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:ac065718db92ca818f8d6141b5f66369833d4a80a9d74435a268c52bdfa73140", size = 236530 },
558 |     { url = "https://files.pythonhosted.org/packages/38/31/3a76f67da4b0cf37b742ca76beaf819dca0ebef26d78fc794a576e08accf/tomli-2.2.1-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:d920f33822747519673ee656a4b6ac33e382eca9d331c87770faa3eef562aeb2", size = 258666 },
559 |     { url = "https://files.pythonhosted.org/packages/07/10/5af1293da642aded87e8a988753945d0cf7e00a9452d3911dd3bb354c9e2/tomli-2.2.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:a198f10c4d1b1375d7687bc25294306e551bf1abfa4eace6650070a5c1ae2744", size = 243954 },
560 |     { url = "https://files.pythonhosted.org/packages/5b/b9/1ed31d167be802da0fc95020d04cd27b7d7065cc6fbefdd2f9186f60d7bd/tomli-2.2.1-cp313-cp313-win32.whl", hash = "sha256:d3f5614314d758649ab2ab3a62d4f2004c825922f9e370b29416484086b264ec", size = 98724 },
561 |     { url = "https://files.pythonhosted.org/packages/c7/32/b0963458706accd9afcfeb867c0f9175a741bf7b19cd424230714d722198/tomli-2.2.1-cp313-cp313-win_amd64.whl", hash = "sha256:a38aa0308e754b0e3c67e344754dff64999ff9b513e691d0e786265c93583c69", size = 109383 },
562 |     { url = "https://files.pythonhosted.org/packages/6e/c2/61d3e0f47e2b74ef40a68b9e6ad5984f6241a942f7cd3bbfbdbd03861ea9/tomli-2.2.1-py3-none-any.whl", hash = "sha256:cb55c73c5f4408779d0cf3eef9f762b9c9f147a77de7b258bef0a5628adc85cc", size = 14257 },
563 | ]
564 | 
565 | [[package]]
566 | name = "trio"
567 | version = "0.26.2"
568 | source = { registry = "https://pypi.org/simple" }
569 | dependencies = [
570 |     { name = "attrs" },
571 |     { name = "cffi", marker = "implementation_name != 'pypy' and os_name == 'nt'" },
572 |     { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
573 |     { name = "idna" },
574 |     { name = "outcome" },
575 |     { name = "sniffio" },
576 |     { name = "sortedcontainers" },
577 | ]
578 | sdist = { url = "https://files.pythonhosted.org/packages/9a/03/ab0e9509be0c6465e2773768ec25ee0cb8053c0b91471ab3854bbf2294b2/trio-0.26.2.tar.gz", hash = "sha256:0346c3852c15e5c7d40ea15972c4805689ef2cb8b5206f794c9c19450119f3a4", size = 561156 }
579 | wheels = [
580 |     { url = "https://files.pythonhosted.org/packages/1c/70/efa56ce2271c44a7f4f43533a0477e6854a0948e9f7b76491de1fd3be7c9/trio-0.26.2-py3-none-any.whl", hash = "sha256:c5237e8133eb0a1d72f09a971a55c28ebe69e351c783fc64bc37db8db8bbe1d0", size = 475996 },
581 | ]
582 | 
583 | [[package]]
584 | name = "typing-extensions"
585 | version = "4.12.2"
586 | source = { registry = "https://pypi.org/simple" }
587 | sdist = { url = "https://files.pythonhosted.org/packages/df/db/f35a00659bc03fec321ba8bce9420de607a1d37f8342eee1863174c69557/typing_extensions-4.12.2.tar.gz", hash = "sha256:1a7ead55c7e559dd4dee8856e3a88b41225abfe1ce8df57b7c13915fe121ffb8", size = 85321 }
588 | wheels = [
589 |     { url = "https://files.pythonhosted.org/packages/26/9f/ad63fc0248c5379346306f8668cda6e2e2e9c95e01216d2b8ffd9ff037d0/typing_extensions-4.12.2-py3-none-any.whl", hash = "sha256:04e5ca0351e0f3f85c6853954072df659d0d13fac324d0072316b67d7794700d", size = 37438 },
590 | ]
591 | 
592 | [[package]]
593 | name = "uvicorn"
594 | version = "0.32.1"
595 | source = { registry = "https://pypi.org/simple" }
596 | dependencies = [
597 |     { name = "click" },
598 |     { name = "h11" },
599 |     { name = "typing-extensions", marker = "python_full_version < '3.11'" },
600 | ]
601 | sdist = { url = "https://files.pythonhosted.org/packages/6a/3c/21dba3e7d76138725ef307e3d7ddd29b763119b3aa459d02cc05fefcff75/uvicorn-0.32.1.tar.gz", hash = "sha256:ee9519c246a72b1c084cea8d3b44ed6026e78a4a309cbedae9c37e4cb9fbb175", size = 77630 }
602 | wheels = [
603 |     { url = "https://files.pythonhosted.org/packages/50/c1/2d27b0a15826c2b71dcf6e2f5402181ef85acf439617bb2f1453125ce1f3/uvicorn-0.32.1-py3-none-any.whl", hash = "sha256:82ad92fd58da0d12af7482ecdb5f2470a04c9c9a53ced65b9bbb4a205377602e", size = 63828 },
604 | ]
605 | 